<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<html>

<head>
  <title>Simics API Functions</title>
  <style>@import url(style.css);</style>
</head>

<body class="jdocu_main">
<script type="text/javascript">
parent.frames['toc'].d.openTo(117, true);
</script>
<a name="label281"></a><p class="jdocu_navbarp"><span class="jdocu_navbar">VIRTUTECH CONFIDENTIAL&nbsp;&nbsp;&nbsp;&nbsp;<a class="jdocu" href="topic7.html">Previous</a> - <a class="jdocu" href="topic5.html">Up</a> - <a class="jdocu" href="topic9.html">Next</a></span></p>
<h3 class="jdocu">3.3&nbsp;&nbsp;&nbsp;Simics API Functions</h3 class="jdocu">


<p>
    <a name="label282"></a><h4 class="jdocu">3.3.1&nbsp;&nbsp;&nbsp;Complete List</h4 class="jdocu">


<table>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1113">MM_FREE</a></td><td class="jdocu_noborder">free vtmem object</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1117">MM_MALIGN</a></td><td class="jdocu_noborder">allocate aligned memory</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1123">MM_MALLOC</a></td><td class="jdocu_noborder">allocate memory object</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1129">MM_REALLOC</a></td><td class="jdocu_noborder">reallocate memory</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1132">MM_STRDUP</a></td><td class="jdocu_noborder">duplicate a string</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label903">PCIE_send_message</a></td><td class="jdocu_noborder">send a message to root complex</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label906">PCI_add_config_register</a></td><td class="jdocu_noborder">add device specific configuration register</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label909">PCI_bridge_default_access_not_taken</a></td><td class="jdocu_noborder">default handling of unclaimed accesses</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label912">PCI_bridge_default_interrupt_lowered</a></td><td class="jdocu_noborder">default handling of secondary interrupts</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label915">PCI_bridge_default_interrupt_raised</a></td><td class="jdocu_noborder">default handling of secondary interrupts</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label918">PCI_bridge_default_system_error</a></td><td class="jdocu_noborder">default system error handling for bridges</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label921">PCI_bridge_init</a></td><td class="jdocu_noborder">Initialize generic PCI bridge device</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label924">PCI_bridge_map_setup</a></td><td class="jdocu_noborder">Set optional memory mapping attributes</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label927">PCI_config_register_name</a></td><td class="jdocu_noborder">return name of a configuration register</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label930">PCI_config_register_size</a></td><td class="jdocu_noborder">return size of a configuration register</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label933">PCI_configuration_access</a></td><td class="jdocu_noborder">access the configuration space</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label937">PCI_data_from_memory</a></td><td class="jdocu_noborder">read/write raw data from memory space</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label937">PCI_data_to_memory</a></td><td class="jdocu_noborder">read/write raw data from memory space</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label940">PCI_default_configuration_read_access</a></td><td class="jdocu_noborder">default function for configuration register reads</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label943">PCI_default_configuration_write_access</a></td><td class="jdocu_noborder">default function for configuration register writes</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label946">PCI_default_device_reset</a></td><td class="jdocu_noborder">default PCI device reset handling</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label949">PCI_device_init</a></td><td class="jdocu_noborder">initialize the generic PCI device</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label952">PCI_get_bus_address</a></td><td class="jdocu_noborder">get the bus address of a device</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label955">PCI_get_config_register_mask</a></td><td class="jdocu_noborder">get write mask of a configuration register</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label993">PCI_get_map_always_on</a></td><td class="jdocu_noborder">query and modify base address mapping</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label993">PCI_get_map_base</a></td><td class="jdocu_noborder">query and modify base address mapping</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label993">PCI_get_map_enable</a></td><td class="jdocu_noborder">query and modify base address mapping</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label993">PCI_get_map_ignore_command</a></td><td class="jdocu_noborder">query and modify base address mapping</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label993">PCI_get_map_offset</a></td><td class="jdocu_noborder">query and modify base address mapping</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label993">PCI_get_map_size</a></td><td class="jdocu_noborder">query and modify base address mapping</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label997">PCI_get_may_stall</a></td><td class="jdocu_noborder">Specifies if memory accesses are stallable</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label959">PCI_handle_mapping32</a></td><td class="jdocu_noborder">handle base address register</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label959">PCI_handle_mapping64</a></td><td class="jdocu_noborder">handle base address register</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label965">PCI_lower_interrupt</a></td><td class="jdocu_noborder">raise and lower a PCI interrupt</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label965">PCI_lower_interrupt_pin</a></td><td class="jdocu_noborder">raise and lower a PCI interrupt</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label965">PCI_raise_interrupt</a></td><td class="jdocu_noborder">raise and lower a PCI interrupt</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label965">PCI_raise_interrupt_pin</a></td><td class="jdocu_noborder">raise and lower a PCI interrupt</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label970">PCI_read_config_register</a></td><td class="jdocu_noborder">read a configuration register</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label970">PCI_read_sized_config_register</a></td><td class="jdocu_noborder">read a configuration register</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label973">PCI_register_bridge_attributes</a></td><td class="jdocu_noborder">register generic PCI bridge attributes</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label976">PCI_register_device_attributes</a></td><td class="jdocu_noborder">register generic PCI device attributes</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label979">PCI_set_config_register_mask</a></td><td class="jdocu_noborder">set write mask of a configuration register</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label993">PCI_set_map_always_on</a></td><td class="jdocu_noborder">query and modify base address mapping</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label993">PCI_set_map_base</a></td><td class="jdocu_noborder">query and modify base address mapping</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label993">PCI_set_map_enable</a></td><td class="jdocu_noborder">query and modify base address mapping</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label993">PCI_set_map_ignore_command</a></td><td class="jdocu_noborder">query and modify base address mapping</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label993">PCI_set_map_offset</a></td><td class="jdocu_noborder">query and modify base address mapping</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label993">PCI_set_map_size</a></td><td class="jdocu_noborder">query and modify base address mapping</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label997">PCI_set_may_stall</a></td><td class="jdocu_noborder">Specifies if memory accesses are stallable</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1000">PCI_system_error</a></td><td class="jdocu_noborder">assert system error</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1004">PCI_value_from_memory</a></td><td class="jdocu_noborder">read/write value from memory space</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1004">PCI_value_to_memory</a></td><td class="jdocu_noborder">read/write value from memory space</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label970">PCI_write_config_register</a></td><td class="jdocu_noborder">read a configuration register</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1007">PCI_write_sized_config_register</a></td><td class="jdocu_noborder">write a configuration register</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label820">SIM_STC_flush_cache</a></td><td class="jdocu_noborder">flush or remove entries in the STCs of a cpu</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label346">SIM_add_configuration</a></td><td class="jdocu_noborder">set configuration from Python</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label689">SIM_add_directory</a></td><td class="jdocu_noborder">add directory to search path</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1193">SIM_add_mode_counter</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label667">SIM_add_output_handler</a></td><td class="jdocu_noborder">register output handler</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1196">SIM_all_classes</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1199">SIM_all_objects</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label287">SIM_alloc_attr_dict</a></td><td class="jdocu_noborder">create empty attribute dictionary</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label290">SIM_alloc_attr_list</a></td><td class="jdocu_noborder">create empty attribute list</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label349">SIM_alloc_conf_object</a></td><td class="jdocu_noborder">allocate object</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label597">SIM_alpha_mem_trans_from_generic</a></td><td class="jdocu_noborder">convert generic transaction to CPU specific</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label597">SIM_arm_mem_trans_from_generic</a></td><td class="jdocu_noborder">convert generic transaction to CPU specific</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label293">SIM_ascanf</a></td><td class="jdocu_noborder">parse list attribute values</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label352">SIM_attribute_error</a></td><td class="jdocu_noborder">specify reason for attribute error</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label325">SIM_break_cycle</a></td><td class="jdocu_noborder">insert breakpoint in time queue</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label784">SIM_break_message</a></td><td class="jdocu_noborder">stop the simulation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label787">SIM_break_simulation</a></td><td class="jdocu_noborder">stop the simulation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label328">SIM_break_step</a></td><td class="jdocu_noborder">set a step breakpoint</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label331">SIM_breakpoint</a></td><td class="jdocu_noborder">set breakpoint</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1202">SIM_breakpoint_action</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label339">SIM_breakpoint_remove</a></td><td class="jdocu_noborder">delete breakpoint range</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1205">SIM_c_frontend_exception</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label604">SIM_c_get_mem_op_value_buf</a></td><td class="jdocu_noborder">get value for a memory operation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label489">SIM_c_hap_occurred</a></td><td class="jdocu_noborder">trigger a hap occurrence</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label489">SIM_c_hap_occurred_always</a></td><td class="jdocu_noborder">trigger a hap occurrence</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label489">SIM_c_hap_occurred_always_vararg</a></td><td class="jdocu_noborder">trigger a hap occurrence</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label489">SIM_c_hap_occurred_vararg</a></td><td class="jdocu_noborder">trigger a hap occurrence</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label611">SIM_c_set_mem_op_value_buf</a></td><td class="jdocu_noborder">set value for a memory operation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label800">SIM_cancel_realtime_event</a></td><td class="jdocu_noborder">cancel callback in host time</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label355">SIM_change_attribute_attribute</a></td><td class="jdocu_noborder">change requiredness of attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1208">SIM_check_exception</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label359">SIM_class_has_attribute</a></td><td class="jdocu_noborder">check if class implements attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1211">SIM_clear_atomic_reservation_bit</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label692">SIM_clear_directories</a></td><td class="jdocu_noborder">clear the search path</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label468">SIM_clear_exception</a></td><td class="jdocu_noborder">clear pending exception</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label473">SIM_command_clear_problem</a></td><td class="jdocu_noborder">signal error in command</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label473">SIM_command_has_problem</a></td><td class="jdocu_noborder">signal error in command</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label473">SIM_command_problem_status</a></td><td class="jdocu_noborder">signal error in command</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label790">SIM_continue</a></td><td class="jdocu_noborder">continue the simulation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label464">SIM_copyright</a></td><td class="jdocu_noborder">get version info about Simics</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1214">SIM_cpu_by_mid</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1217">SIM_cpu_enabled</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1220">SIM_cpu_issue_cycles</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1223">SIM_cpu_privilege_level</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label362">SIM_create_object</a></td><td class="jdocu_noborder">create and initialise object</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label705">SIM_current_processor</a></td><td class="jdocu_noborder">get current processor</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label842">SIM_cycle_count</a></td><td class="jdocu_noborder">query time queue for current time</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label342">SIM_delete_breakpoint</a></td><td class="jdocu_noborder">delete breakpoint</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label365">SIM_delete_object</a></td><td class="jdocu_noborder">delete object</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1226">SIM_device_log</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label713">SIM_disable_processor</a></td><td class="jdocu_noborder">enable or disable a processor</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label708">SIM_disassemble</a></td><td class="jdocu_noborder">disassemble instruction</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1229">SIM_disassemble_physical</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1232">SIM_dump_caches</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label713">SIM_enable_processor</a></td><td class="jdocu_noborder">enable or disable a processor</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label368">SIM_ensure_partial_attr_order</a></td><td class="jdocu_noborder">ensure attribute order</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1235">SIM_exception_has_occurred</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label679">SIM_flush</a></td><td class="jdocu_noborder">text output routines</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label820">SIM_flush_D_STC_logical</a></td><td class="jdocu_noborder">flush or remove entries in the STCs of a cpu</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label820">SIM_flush_D_STC_physical</a></td><td class="jdocu_noborder">flush or remove entries in the STCs of a cpu</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label820">SIM_flush_I_STC_logical</a></td><td class="jdocu_noborder">flush or remove entries in the STCs of a cpu</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label820">SIM_flush_I_STC_physical</a></td><td class="jdocu_noborder">flush or remove entries in the STCs of a cpu</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label823">SIM_flush_all_caches</a></td><td class="jdocu_noborder">clear Simics's internal caches</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1238">SIM_for_all_hap_types</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label563">SIM_for_all_memory_pages</a></td><td class="jdocu_noborder">apply callback function to all memory pages</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1241">SIM_for_all_modules</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1244">SIM_for_all_modules_failed</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1247">SIM_for_all_processors</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label371">SIM_free_attribute</a></td><td class="jdocu_noborder">free attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label476">SIM_frontend_exception</a></td><td class="jdocu_noborder">raise an exception</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1250">SIM_get_No_Exception</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label374">SIM_get_all_classes</a></td><td class="jdocu_noborder">get list of all classes</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label724">SIM_get_all_exceptions</a></td><td class="jdocu_noborder">processor exception conversion utilities</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label653">SIM_get_all_failed_modules</a></td><td class="jdocu_noborder">return a list of all modules that failed to load</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label492">SIM_get_all_hap_types</a></td><td class="jdocu_noborder">get list of all hap types</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label656">SIM_get_all_modules</a></td><td class="jdocu_noborder">return a list of all modules</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label377">SIM_get_all_objects</a></td><td class="jdocu_noborder">get list of all objects</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label716">SIM_get_all_processors</a></td><td class="jdocu_noborder">get list of all processors</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label719">SIM_get_all_registers</a></td><td class="jdocu_noborder">get all register numbers</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label383">SIM_get_attribute</a></td><td class="jdocu_noborder">get attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label386">SIM_get_attribute_attributes</a></td><td class="jdocu_noborder">get attribute flags</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label383">SIM_get_attribute_idx</a></td><td class="jdocu_noborder">get attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1253">SIM_get_base_pointer</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label879">SIM_get_batch_mode</a></td><td class="jdocu_noborder">return setting of the batch-mode</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label389">SIM_get_class</a></td><td class="jdocu_noborder">get class</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label383">SIM_get_class_attribute</a></td><td class="jdocu_noborder">get attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label383">SIM_get_class_attribute_idx</a></td><td class="jdocu_noborder">get attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label402">SIM_get_class_interface</a></td><td class="jdocu_noborder">get interface</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label393">SIM_get_class_name</a></td><td class="jdocu_noborder">get class name</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label402">SIM_get_class_port_interface</a></td><td class="jdocu_noborder">get interface</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label396">SIM_get_configuration_file_prefix</a></td><td class="jdocu_noborder">get filename prefix</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1256">SIM_get_control_register_name</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1259">SIM_get_control_register_number</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1262">SIM_get_current_proc_no</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label695">SIM_get_directories</a></td><td class="jdocu_noborder">get the current search path</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label724">SIM_get_exception_name</a></td><td class="jdocu_noborder">processor exception conversion utilities</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label724">SIM_get_exception_number</a></td><td class="jdocu_noborder">processor exception conversion utilities</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1265">SIM_get_file_size</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1268">SIM_get_history_match</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label402">SIM_get_interface</a></td><td class="jdocu_noborder">get interface</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label614">SIM_get_mem_op_type</a></td><td class="jdocu_noborder">get type of transaction</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label617">SIM_get_mem_op_type_name</a></td><td class="jdocu_noborder">get name of memory operation type</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label604">SIM_get_mem_op_value_be</a></td><td class="jdocu_noborder">get value for a memory operation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label604">SIM_get_mem_op_value_buf</a></td><td class="jdocu_noborder">get value for a memory operation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label604">SIM_get_mem_op_value_cpu</a></td><td class="jdocu_noborder">get value for a memory operation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label604">SIM_get_mem_op_value_le</a></td><td class="jdocu_noborder">get value for a memory operation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1271">SIM_get_mmu_data</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1274">SIM_get_mode_counter</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label405">SIM_get_object</a></td><td class="jdocu_noborder">get object</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label479">SIM_get_pending_exception</a></td><td class="jdocu_noborder">get current pending exception</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label402">SIM_get_port_interface</a></td><td class="jdocu_noborder">get interface</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1277">SIM_get_proc_no</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label727">SIM_get_processor</a></td><td class="jdocu_noborder">get processor pointer from number</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label730">SIM_get_processor_number</a></td><td class="jdocu_noborder">get the number of a processor</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label734">SIM_get_program_counter</a></td><td class="jdocu_noborder">read/write program counter</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label533">SIM_get_quiet</a></td><td class="jdocu_noborder">return setting of the quiet flag</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label738">SIM_get_register_name</a></td><td class="jdocu_noborder">convert between register name and register number</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label738">SIM_get_register_number</a></td><td class="jdocu_noborder">convert between register name and register number</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1280">SIM_get_simics_home</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1283">SIM_get_stack_pointer</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1286">SIM_get_trap_time</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_get_unique_memory_transaction_id</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label620">SIM_get_unique_memory_transaction_id</a></td><td class="jdocu_noborder">get unique memory transaction ID</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label536">SIM_get_verbose</a></td><td class="jdocu_noborder">get the verbose flag</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label500">SIM_hap_add_callback</a></td><td class="jdocu_noborder">install callback on a hap</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label500">SIM_hap_add_callback_index</a></td><td class="jdocu_noborder">install callback on a hap</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label500">SIM_hap_add_callback_obj</a></td><td class="jdocu_noborder">install callback on a hap</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label500">SIM_hap_add_callback_obj_index</a></td><td class="jdocu_noborder">install callback on a hap</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label500">SIM_hap_add_callback_obj_range</a></td><td class="jdocu_noborder">install callback on a hap</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label500">SIM_hap_add_callback_range</a></td><td class="jdocu_noborder">install callback on a hap</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label504">SIM_hap_add_type</a></td><td class="jdocu_noborder">register a new hap type</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label507">SIM_hap_callback_exists</a></td><td class="jdocu_noborder">get callback status</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label513">SIM_hap_delete_callback</a></td><td class="jdocu_noborder">delete installed hap callback</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label513">SIM_hap_delete_callback_id</a></td><td class="jdocu_noborder">delete installed hap callback</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label513">SIM_hap_delete_callback_obj</a></td><td class="jdocu_noborder">delete installed hap callback</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label513">SIM_hap_delete_callback_obj_id</a></td><td class="jdocu_noborder">delete installed hap callback</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label516">SIM_hap_get_name</a></td><td class="jdocu_noborder">get hap name by number</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label519">SIM_hap_get_number</a></td><td class="jdocu_noborder">get hap number by name</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1289">SIM_hap_install_callback</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1292">SIM_hap_install_callback_idx</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1295">SIM_hap_install_callback_range</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label522">SIM_hap_is_active</a></td><td class="jdocu_noborder">check if hap has callbacks</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1298">SIM_hap_new_type</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label526">SIM_hap_occurred</a></td><td class="jdocu_noborder">trigger hap occurrence</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label526">SIM_hap_occurred_always</a></td><td class="jdocu_noborder">trigger hap occurrence</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1301">SIM_hap_register_callback</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1304">SIM_hap_register_callback_idx</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1307">SIM_hap_register_callback_range</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1310">SIM_hap_remove_callback</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label529">SIM_hap_remove_type</a></td><td class="jdocu_noborder">remove a hap type</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1313">SIM_hap_unregister_callback</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label597">SIM_ia64_mem_trans_from_generic</a></td><td class="jdocu_noborder">convert generic transaction to CPU specific</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1316">SIM_inc_cur_mode_counter</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1319">SIM_inc_mode_counter</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label408">SIM_initial_configuration_ok</a></td><td class="jdocu_noborder">get configuration status</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1322">SIM_install_default_ASI_handler</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1325">SIM_install_user_ASI_handler</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_begin</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_child</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_commit</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_cpu</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_decode</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_end</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_execute</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_fetch</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_force_correct</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_get_field_value</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_get_reg_info</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_get_user_data</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_handle_exception</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_handle_interrupt</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_id_from_mem_op_id</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1328">SIM_instruction_info</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_insert</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_is_sync</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_length</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_nth_id</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_opcode</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_parent</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_phase</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_proceed</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_read_input_reg</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_read_output_reg</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_remaining_stall_time</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_retire</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_rewind</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_set_stop_phase</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_set_user_data</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_speculative</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_squash</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_stalling_mem_op</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_status</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_store_queue_mem_op</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_type</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_write_input_reg</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_instruction_write_output_reg</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label882">SIM_is_interactive</a></td><td class="jdocu_noborder">running interactive command predicate</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label780">SIM_iter_addr</a></td><td class="jdocu_noborder">Iterate over address profile counters</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label780">SIM_iter_free</a></td><td class="jdocu_noborder">Iterate over address profile counters</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label780">SIM_iter_next</a></td><td class="jdocu_noborder">Iterate over address profile counters</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label482">SIM_last_error</a></td><td class="jdocu_noborder">get error message from last exception</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label464">SIM_license</a></td><td class="jdocu_noborder">get version info about Simics</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label566">SIM_load_binary</a></td><td class="jdocu_noborder">read an executable file into memory</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label569">SIM_load_file</a></td><td class="jdocu_noborder">read a file into memory</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label660">SIM_load_module</a></td><td class="jdocu_noborder">load/unload modules</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label539">SIM_log_constructor</a></td><td class="jdocu_noborder">initiate log class</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label547">SIM_log_error</a></td><td class="jdocu_noborder">output log message</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label547">SIM_log_info</a></td><td class="jdocu_noborder">output log message</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label550">SIM_log_message</a></td><td class="jdocu_noborder">print and log message</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label553">SIM_log_register_groups</a></td><td class="jdocu_noborder">register names of log groups</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label547">SIM_log_spec_violation</a></td><td class="jdocu_noborder">output log message</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label547">SIM_log_target_error</a></td><td class="jdocu_noborder">output log message</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label547">SIM_log_undefined</a></td><td class="jdocu_noborder">output log message</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label547">SIM_log_unimplemented</a></td><td class="jdocu_noborder">output log message</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label572">SIM_logical_to_physical</a></td><td class="jdocu_noborder">translate logical to physical</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label698">SIM_lookup_file</a></td><td class="jdocu_noborder">find a file using simics-path</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label296">SIM_make_attr_boolean</a></td><td class="jdocu_noborder">make boolean attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label299">SIM_make_attr_data</a></td><td class="jdocu_noborder">create raw data attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label302">SIM_make_attr_floating</a></td><td class="jdocu_noborder">make floating point attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label305">SIM_make_attr_integer</a></td><td class="jdocu_noborder">make integer attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label308">SIM_make_attr_invalid</a></td><td class="jdocu_noborder">make invalid attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label312">SIM_make_attr_list</a></td><td class="jdocu_noborder">make list attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label312">SIM_make_attr_list_vararg</a></td><td class="jdocu_noborder">make list attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label315">SIM_make_attr_nil</a></td><td class="jdocu_noborder">make empty attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label318">SIM_make_attr_object</a></td><td class="jdocu_noborder">make object attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label321">SIM_make_attr_string</a></td><td class="jdocu_noborder">make string attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label623">SIM_mem_op_is_control</a></td><td class="jdocu_noborder">transaction control predicates</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label627">SIM_mem_op_is_data</a></td><td class="jdocu_noborder">transaction data/instruction predicates</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label630">SIM_mem_op_is_from_cache</a></td><td class="jdocu_noborder">Cache initiated transaction</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label633">SIM_mem_op_is_from_cpu</a></td><td class="jdocu_noborder">CPU initiated transaction</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label636">SIM_mem_op_is_from_cpu_arch</a></td><td class="jdocu_noborder">CPU initiated transaction</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label639">SIM_mem_op_is_from_device</a></td><td class="jdocu_noborder">Device initiated transaction</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label627">SIM_mem_op_is_instruction</a></td><td class="jdocu_noborder">transaction data/instruction predicates</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label642">SIM_mem_op_is_prefetch</a></td><td class="jdocu_noborder">transaction control predicates</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label646">SIM_mem_op_is_read</a></td><td class="jdocu_noborder">transaction read/write predicates</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label646">SIM_mem_op_is_write</a></td><td class="jdocu_noborder">transaction read/write predicates</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label597">SIM_mips_mem_trans_from_generic</a></td><td class="jdocu_noborder">convert generic transaction to CPU specific</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label663">SIM_module_list_refresh</a></td><td class="jdocu_noborder">refresh list of loadable modules</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label701">SIM_native_path</a></td><td class="jdocu_noborder">convert path to its native form</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label411">SIM_new_object</a></td><td class="jdocu_noborder">create object</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label845">SIM_next_queue</a></td><td class="jdocu_noborder">get next object that owns a queue</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1331">SIM_no_windows</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label805">SIM_notify_on_descriptor</a></td><td class="jdocu_noborder">register notification on host I/O events</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label805">SIM_notify_on_object</a></td><td class="jdocu_noborder">register notification on host I/O events</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label805">SIM_notify_on_socket</a></td><td class="jdocu_noborder">register notification on host I/O events</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1334">SIM_num_control_registers</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label741">SIM_number_processors</a></td><td class="jdocu_noborder">number of processors</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1337">SIM_object_by_id</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label414">SIM_object_constructor</a></td><td class="jdocu_noborder">base class constructor</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label417">SIM_object_is_processor</a></td><td class="jdocu_noborder">test if object is a processor</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label597">SIM_pci_mem_trans_from_generic</a></td><td class="jdocu_noborder">convert generic transaction to CPU specific</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label885">SIM_post_command</a></td><td class="jdocu_noborder">post callback to be run when simulation is stopped</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label793">SIM_postponing_continue</a></td><td class="jdocu_noborder">ask if continue will be postponed</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label597">SIM_ppc_mem_trans_from_generic</a></td><td class="jdocu_noborder">convert generic transaction to CPU specific</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label679">SIM_printf</a></td><td class="jdocu_noborder">text output routines</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label679">SIM_printf_vararg</a></td><td class="jdocu_noborder">text output routines</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1340">SIM_proc_no_2_ptr</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1343">SIM_processor_break</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label744">SIM_processor_enabled</a></td><td class="jdocu_noborder">check if processor is enabled</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label747">SIM_processor_privilege_level</a></td><td class="jdocu_noborder">return the current privilege level for a processor</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label679">SIM_putchar</a></td><td class="jdocu_noborder">text output routines</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label679">SIM_puts</a></td><td class="jdocu_noborder">text output routines</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label888">SIM_quit</a></td><td class="jdocu_noborder">quit Simics</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1346">SIM_raise_general_exception</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label576">SIM_read_byte</a></td><td class="jdocu_noborder">read/write byte from a memory space</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label420">SIM_read_configuration</a></td><td class="jdocu_noborder">read configuration</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1349">SIM_read_control_register</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1352">SIM_read_fp_register</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1355">SIM_read_fp_register_d</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1358">SIM_read_fp_register_i</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1361">SIM_read_fp_register_s</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1364">SIM_read_fp_register_x</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1367">SIM_read_global_register</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label579">SIM_read_phys_memory</a></td><td class="jdocu_noborder">read data from a physical address</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label583">SIM_read_phys_memory_tags</a></td><td class="jdocu_noborder">access auxiliary bits in physical memory</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label750">SIM_read_register</a></td><td class="jdocu_noborder">get register value</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1370">SIM_read_window_register</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label464">SIM_readme</a></td><td class="jdocu_noborder">get version info about Simics</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label809">SIM_realtime_event</a></td><td class="jdocu_noborder">schedule callback in host time</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label754">SIM_register_arch_decoder</a></td><td class="jdocu_noborder">install/uninstall instruction decoders</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label424">SIM_register_attribute</a></td><td class="jdocu_noborder">register attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label427">SIM_register_class</a></td><td class="jdocu_noborder">register class</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label430">SIM_register_class_alias</a></td><td class="jdocu_noborder">register class alias</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label424">SIM_register_class_attribute</a></td><td class="jdocu_noborder">register attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label456">SIM_register_copyright</a></td><td class="jdocu_noborder">register copyright information</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label763">SIM_register_decoder</a></td><td class="jdocu_noborder">deprecated install/uninstall user decoders</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label434">SIM_register_interface</a></td><td class="jdocu_noborder">register interface</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label434">SIM_register_port_interface</a></td><td class="jdocu_noborder">register interface</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label438">SIM_register_typed_attribute</a></td><td class="jdocu_noborder">register attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label438">SIM_register_typed_class_attribute</a></td><td class="jdocu_noborder">register attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1051">SIM_release_stall</a></td><td class="jdocu_noborder">Micro-Architecture Interface functions</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label827">SIM_release_stall</a></td><td class="jdocu_noborder">release stalling transaction</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label671">SIM_remove_output_handler</a></td><td class="jdocu_noborder">unregister output handler</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label771">SIM_reset_processor</a></td><td class="jdocu_noborder">reset the processor</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label891">SIM_run_command_file</a></td><td class="jdocu_noborder">read CLI commands from file</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label445">SIM_set_attribute</a></td><td class="jdocu_noborder">set attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label445">SIM_set_attribute_idx</a></td><td class="jdocu_noborder">set attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label445">SIM_set_class_attribute</a></td><td class="jdocu_noborder">set attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label445">SIM_set_class_attribute_idx</a></td><td class="jdocu_noborder">set attribute</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label449">SIM_set_configuration</a></td><td class="jdocu_noborder">set configuration from data</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label649">SIM_set_mem_op_type</a></td><td class="jdocu_noborder">set type of transaction</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label611">SIM_set_mem_op_value_be</a></td><td class="jdocu_noborder">set value for a memory operation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label611">SIM_set_mem_op_value_buf</a></td><td class="jdocu_noborder">set value for a memory operation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label611">SIM_set_mem_op_value_cpu</a></td><td class="jdocu_noborder">set value for a memory operation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label611">SIM_set_mem_op_value_le</a></td><td class="jdocu_noborder">set value for a memory operation</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1373">SIM_set_mode_counter</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label734">SIM_set_program_counter</a></td><td class="jdocu_noborder">read/write program counter</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label894">SIM_set_prompt</a></td><td class="jdocu_noborder">change prompt in Simics</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label556">SIM_set_quiet</a></td><td class="jdocu_noborder">enable/disable quiet mode</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label559">SIM_set_verbose</a></td><td class="jdocu_noborder">set the verbose flag</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label796">SIM_simics_is_running</a></td><td class="jdocu_noborder">check if Simics is running</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label464">SIM_snapshot_date</a></td><td class="jdocu_noborder">get version info about Simics</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label898">SIM_source_python</a></td><td class="jdocu_noborder">execute Python source file</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label898">SIM_source_python_in_module</a></td><td class="jdocu_noborder">execute Python source file</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1376">SIM_sparc_ASI_info</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label848">SIM_stacked_post</a></td><td class="jdocu_noborder">insert an event that runs as soon as possible</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label834">SIM_stall</a></td><td class="jdocu_noborder">stall execution a specified number of cycles</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label830">SIM_stall_count</a></td><td class="jdocu_noborder">get number of cycles a processor has been stalled</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label834">SIM_stall_cycle</a></td><td class="jdocu_noborder">stall execution a specified number of cycles</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label837">SIM_stalled_until</a></td><td class="jdocu_noborder">query how many cycles that remains of stall</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label851">SIM_step_clean</a></td><td class="jdocu_noborder">remove events from the step queue</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label854">SIM_step_count</a></td><td class="jdocu_noborder">query step queue count</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label857">SIM_step_next_occurrence</a></td><td class="jdocu_noborder">get number of steps until a step queue event occurs</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label860">SIM_step_post</a></td><td class="jdocu_noborder">add an event in step queue</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label812">SIM_thread_safe_callback</a></td><td class="jdocu_noborder">call function synchronized with main thread</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label842">SIM_time</a></td><td class="jdocu_noborder">query time queue for current time</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label865">SIM_time_clean</a></td><td class="jdocu_noborder">remove all matching events from time queue</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label868">SIM_time_next_occurrence</a></td><td class="jdocu_noborder">get cycles to matching event</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label872">SIM_time_post</a></td><td class="jdocu_noborder">add event to time queue</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label872">SIM_time_post_cycle</a></td><td class="jdocu_noborder">add event to time queue</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label660">SIM_unload_module</a></td><td class="jdocu_noborder">load/unload modules</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label754">SIM_unregister_arch_decoder</a></td><td class="jdocu_noborder">install/uninstall instruction decoders</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label763">SIM_unregister_decoder</a></td><td class="jdocu_noborder">deprecated install/uninstall user decoders</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label597">SIM_v9_mem_trans_from_generic</a></td><td class="jdocu_noborder">convert generic transaction to CPU specific</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label464">SIM_version</a></td><td class="jdocu_noborder">get version info about Simics</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label464">SIM_version_sub</a></td><td class="jdocu_noborder">get version info about Simics</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1379">SIM_void_to_processor_t</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label679">SIM_write</a></td><td class="jdocu_noborder">text output routines</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label576">SIM_write_byte</a></td><td class="jdocu_noborder">read/write byte from a memory space</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label452">SIM_write_configuration_to_file</a></td><td class="jdocu_noborder">write configuration</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1382">SIM_write_control_register</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1385">SIM_write_fp_register</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1388">SIM_write_fp_register_d</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1391">SIM_write_fp_register_i</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1394">SIM_write_fp_register_s</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1397">SIM_write_fp_register_x</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1400">SIM_write_global_register</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label586">SIM_write_phys_memory</a></td><td class="jdocu_noborder">write data to a physical address</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label583">SIM_write_phys_memory_tags</a></td><td class="jdocu_noborder">access auxiliary bits in physical memory</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label774">SIM_write_register</a></td><td class="jdocu_noborder">set register value</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="topic9.html#label1403">SIM_write_window_register</a></td><td class="jdocu_noborder"><i>obsolete API function</i></td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label597">SIM_x86_mem_trans_from_generic</a></td><td class="jdocu_noborder">convert generic transaction to CPU specific</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1138">cli.arg</a></td><td class="jdocu_noborder">define a command argument</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1142">cli.eval_cli_line</a></td><td class="jdocu_noborder">evaluate a CLI command line</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1146">cli.get_available_object_name</a></td><td class="jdocu_noborder">return a non-allocated object name</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1150">cli.new_command</a></td><td class="jdocu_noborder">define a new CLI command</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1154">cli.number_str</a></td><td class="jdocu_noborder">return a ready-to-print representation of a number</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1158">cli.object_expander</a></td><td class="jdocu_noborder">Standard expander for an object argument</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1162">cli.quiet_run_command</a></td><td class="jdocu_noborder">Run a CLI command and return output</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1166">cli.run_command</a></td><td class="jdocu_noborder">Run a CLI command</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1058">dbuffer_append</a></td><td class="jdocu_noborder">Add data to a dbuffer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1062">dbuffer_append_external_data</a></td><td class="jdocu_noborder">Add static data</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1066">dbuffer_append_value</a></td><td class="jdocu_noborder">Add data with uniform content</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1069">dbuffer_clone</a></td><td class="jdocu_noborder">Make a full copy of another buffer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1073">dbuffer_copy_append</a></td><td class="jdocu_noborder">Copy data from a dbuffer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1073">dbuffer_copy_prepend</a></td><td class="jdocu_noborder">Copy data from a dbuffer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1076">dbuffer_free</a></td><td class="jdocu_noborder">Release a dbuffer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1058">dbuffer_insert</a></td><td class="jdocu_noborder">Add data to a dbuffer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1079">dbuffer_len</a></td><td class="jdocu_noborder">Get the size of a dbuffer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1058">dbuffer_prepend</a></td><td class="jdocu_noborder">Add data to a dbuffer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1062">dbuffer_prepend_external_data</a></td><td class="jdocu_noborder">Add static data</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1066">dbuffer_prepend_value</a></td><td class="jdocu_noborder">Add data with uniform content</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1084">dbuffer_read</a></td><td class="jdocu_noborder">Extract data for reading</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1084">dbuffer_read_all</a></td><td class="jdocu_noborder">Extract data for reading</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1084">dbuffer_read_some</a></td><td class="jdocu_noborder">Extract data for reading</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1089">dbuffer_remove</a></td><td class="jdocu_noborder">Remove data from a dbuffer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1089">dbuffer_remove_head</a></td><td class="jdocu_noborder">Remove data from a dbuffer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1089">dbuffer_remove_tail</a></td><td class="jdocu_noborder">Remove data from a dbuffer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1094">dbuffer_replace</a></td><td class="jdocu_noborder">Replace data</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1094">dbuffer_replace_all</a></td><td class="jdocu_noborder">Replace data</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1094">dbuffer_replace_some</a></td><td class="jdocu_noborder">Replace data</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1097">dbuffer_split</a></td><td class="jdocu_noborder">Split a dbuffer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1102">dbuffer_update</a></td><td class="jdocu_noborder">Extract data for updating</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1102">dbuffer_update_all</a></td><td class="jdocu_noborder">Extract data for updating</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1102">dbuffer_update_some</a></td><td class="jdocu_noborder">Extract data for updating</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1105">new_dbuffer</a></td><td class="jdocu_noborder">Create a new dbuffer</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1170">sim_commands.new_info_command</a></td><td class="jdocu_noborder">define a new info command</td></tr>
<tr><td class="jdocu_noborder"><a class="jdocu" href="#label1174">sim_commands.new_status_command</a></td><td class="jdocu_noborder">define a new status command</td></tr>
</table>

    <a name="label283"></a><h4 class="jdocu">3.3.2&nbsp;&nbsp;&nbsp;Core</h4 class="jdocu">




<p>
<a name="label284"></a><h5 class="jdocu">Attribute Values</h5 class="jdocu">
<a name="label285"></a><h6 class="jdocu">SIM_alloc_attr_dict()</h6 class="jdocu">

<a name="label286"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label287"></a><b>SIM_alloc_attr_dict</b> &#8212; create empty attribute dictionary</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">attr_value_t
SIM_alloc_attr_dict(int length);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <tt>attr_value_t</tt> of type
  <tt>Sim_Val_Dict</tt> with size <i>len</i>. The dictionary
  elements are initialized to <tt>Sim_Val_Invalid</tt>.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label290">SIM_alloc_attr_list</a></dl>
<a name="label288"></a><h6 class="jdocu">SIM_alloc_attr_list()</h6 class="jdocu">

<a name="label289"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label290"></a><b>SIM_alloc_attr_list</b> &#8212; create empty attribute list</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">attr_value_t
SIM_alloc_attr_list(int length);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <tt>attr_value_t</tt> of type
  <tt>Sim_Val_List</tt> with size <i>len</i>. The list
  elements are initialized to <tt>Sim_Val_Invalid</tt>.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label312">SIM_make_attr_list</a></dl>
<a name="label291"></a><h6 class="jdocu">SIM_ascanf()</h6 class="jdocu">

<a name="label292"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label293"></a><b>SIM_ascanf</b> &#8212; parse list attribute values</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_ascanf(attr_value_t *list, const char *fmt, ...);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Reads and converts entries in <i>list</i> according to the format string
   <i>fmt</i>. Returns 1 if all elements were successfully converted, 0
   otherwise.
<p>
   The characters in the format string mean:
<p>
   <span class="jdocu_smaller">
   <table>
<tr><td class="jdocu_border"><b>format char</b></td><td class="jdocu_border"><b>argument type</b></td><td class="jdocu_border"><b>element must be</b></td></tr>
<tr><td class="jdocu_border"><tt>i</tt></td><td class="jdocu_border"><tt>integer_t *</tt></td><td class="jdocu_border"><tt>Sim_Val_Integer</tt></td></tr>
<tr><td class="jdocu_border"><tt>b</tt></td><td class="jdocu_border"><tt>int *</tt></td><td class="jdocu_border"><tt>Sim_Val_Boolean</tt></td></tr>
<tr><td class="jdocu_border"><tt>f</tt></td><td class="jdocu_border"><tt>double *</tt></td><td class="jdocu_border"><tt>Sim_Val_Floating</tt></td></tr>
<tr><td class="jdocu_border"><tt>s</tt></td><td class="jdocu_border"><tt>const char **</tt></td><td class="jdocu_border"><tt>Sim_Val_String</tt></td></tr>
<tr><td class="jdocu_border"><tt>S</tt></td><td class="jdocu_border"><tt>const char **</tt></td><td class="jdocu_border"><tt>Sim_Val_String</tt> or <tt>Sim_Val_Nil</tt></td></tr>
<tr><td class="jdocu_border"><tt>o</tt></td><td class="jdocu_border"><tt>conf_object_t **</tt></td><td class="jdocu_border"><tt>Sim_Val_Object</tt></td></tr>
<tr><td class="jdocu_border"><tt>O</tt></td><td class="jdocu_border"><tt>conf_object_t **</tt></td><td class="jdocu_border"><tt>Sim_Val_Object</tt> or <tt>Sim_Val_Nil</tt></td></tr>
<tr><td class="jdocu_border"><tt>l</tt></td><td class="jdocu_border"><tt>attr_value_t **</tt></td><td class="jdocu_border"><tt>Sim_Val_List</tt></td></tr>
<tr><td class="jdocu_border"><tt>d</tt></td><td class="jdocu_border"><tt>attr_value_t **</tt></td><td class="jdocu_border"><tt>Sim_Val_Data</tt></td></tr>
<tr><td class="jdocu_border"><tt>a</tt></td><td class="jdocu_border"><tt>attr_value_t **</tt></td><td class="jdocu_border">any except <tt>Sim_Val_Invalid</tt></td></tr>
</table>
   </span>
<p>
   The <i>fmt</i> string may also include a period (<tt>.</tt>) at the end,
   taken to mean that more elements may follow. If the period is not present,
   the length of the list must equal the number of specified elements.</dd>

<p>
</dl>
<a name="label294"></a><h6 class="jdocu">SIM_make_attr_boolean()</h6 class="jdocu">

<a name="label295"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label296"></a><b>SIM_make_attr_boolean</b> &#8212; make boolean attribute</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">attr_value_t
SIM_make_attr_boolean(integer_t b);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <tt>attr_value_t</tt> of type <tt>Sim_Val_Boolean</tt>.</dd>

<p>
</dl>
<a name="label297"></a><h6 class="jdocu">SIM_make_attr_data()</h6 class="jdocu">

<a name="label298"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label299"></a><b>SIM_make_attr_data</b> &#8212; create raw data attribute</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">attr_value_t
SIM_make_attr_data(integer_t size, void *data);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <tt>attr_value_t</tt> of type
  <tt>Sim_Val_Data</tt> using <i>size</i> and
  <i>data</i> for the binary data. No copy is made of
  <i>data</i>.</dd>

<p>
</dl>
<a name="label300"></a><h6 class="jdocu">SIM_make_attr_floating()</h6 class="jdocu">

<a name="label301"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label302"></a><b>SIM_make_attr_floating</b> &#8212; make floating point attribute</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">attr_value_t
SIM_make_attr_floating(double d);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <tt>attr_value_t</tt> of type <tt>Sim_Val_Floating</tt>
   with value <tt>d</tt>.</dd>

<p>
</dl>
<a name="label303"></a><h6 class="jdocu">SIM_make_attr_integer()</h6 class="jdocu">

<a name="label304"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label305"></a><b>SIM_make_attr_integer</b> &#8212; make integer attribute</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">attr_value_t
SIM_make_attr_integer(integer_t i);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <tt>attr_value_t</tt> of type <tt>Sim_Val_Integer</tt>
   with value <tt>i</tt>.</dd>

<p>
</dl>
<a name="label306"></a><h6 class="jdocu">SIM_make_attr_invalid()</h6 class="jdocu">

<a name="label307"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label308"></a><b>SIM_make_attr_invalid</b> &#8212; make invalid attribute</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">attr_value_t
SIM_make_attr_invalid(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <tt>attr_value_t</tt> of type <tt>Sim_Val_Invalid</tt>.</dd>

<p>
</dl>
<a name="label309"></a><h6 class="jdocu">SIM_make_attr_list()</h6 class="jdocu">

<a name="label310"></a><a name="label311"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label312"></a><b>SIM_make_attr_list</b><b>, SIM_make_attr_list_vararg</b> &#8212; make list attribute</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">attr_value_t
SIM_make_attr_list(int length, ...);
</pre><pre class="jdocu_small" style="color: black">attr_value_t
SIM_make_attr_list_vararg(int length, va_list va);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <tt>attr_value_t</tt> of type <tt>Sim_Val_List</tt>
   with size <i>length</i>. The list is filled with data from the
   arguments following, which should be of type <tt>attr_value_t</tt>.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label290">SIM_alloc_attr_list</a></dl>
<a name="label313"></a><h6 class="jdocu">SIM_make_attr_nil()</h6 class="jdocu">

<a name="label314"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label315"></a><b>SIM_make_attr_nil</b> &#8212; make empty attribute</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">attr_value_t
SIM_make_attr_nil(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <tt>attr_value_t</tt> of type <tt>Sim_Val_Nil</tt>.</dd>

<p>
</dl>
<a name="label316"></a><h6 class="jdocu">SIM_make_attr_object()</h6 class="jdocu">

<a name="label317"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label318"></a><b>SIM_make_attr_object</b> &#8212; make object attribute</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">attr_value_t
SIM_make_attr_object(conf_object_t *obj);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <tt>attr_value_t</tt> of type <tt>Sim_Val_Object</tt>
   with value <i>obj</i>. Returns a <tt>Sim_Val_Nil</tt> if
   <i>obj</i> is <tt>NULL</tt>.</dd>

<p>
</dl>
<a name="label319"></a><h6 class="jdocu">SIM_make_attr_string()</h6 class="jdocu">

<a name="label320"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label321"></a><b>SIM_make_attr_string</b> &#8212; make string attribute</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">attr_value_t
SIM_make_attr_string(const char *str);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns an <tt>attr_value_t</tt> of type <tt>Sim_Val_String</tt>
   with value <i>str</i>. Returns a <tt>Sim_Val_Nil</tt> if
   <i>str</i> is <tt>NULL</tt>.</dd>

<p>
</dl>

<a name="label322"></a><h5 class="jdocu">Breakpoints</h5 class="jdocu">
<a name="label323"></a><h6 class="jdocu">SIM_break_cycle()</h6 class="jdocu">

<a name="label324"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label325"></a><b>SIM_break_cycle</b> &#8212; insert breakpoint in time queue</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_break_cycle(conf_object_t *obj, integer_t cycles);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
SIM_break_cycle inserts a breakpoint event at <i>cycles</i> clock cycles
   from now causing simulation to stop and returning to prompt. Useful in
   conjunction with a stalling timing model where there no longer is a one to
   one correspondence between cycles and steps.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
 <b>General</b> Thrown if <i>obj</i> is
    <tt>NULL</tt>.<br>
   <b>General</b> Thrown if <i>clock_cycles</i> is negative.</dd>
</dl>
<a name="label326"></a><h6 class="jdocu">SIM_break_step()</h6 class="jdocu">

<a name="label327"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label328"></a><b>SIM_break_step</b> &#8212; set a step breakpoint</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_break_step(conf_object_t *obj, integer_t steps);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Sets a step breakpoint on a processor. The <i>steps</i>
   argument is the number of instructions until the break occurs.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>General</b> If <i>obj</i> is NULL, or
   the time specified is illegal.</dd>
</dl>
<a name="label329"></a><h6 class="jdocu">SIM_breakpoint()</h6 class="jdocu">

<a name="label330"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label331"></a><b>SIM_breakpoint</b> &#8212; set breakpoint</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">breakpoint_id_t
SIM_breakpoint(conf_object_t *obj,
               breakpoint_kind_t kind,
               access_t access,
               uint64 address,
               uint64 length,
               unsigned flags);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Add breakpoint on an <i>object</i> implementing the breakpoint
   interface. This is typically a memory space object such as physical memory.
<p>
   The <i>kind</i> argument sets what type of address to break on:
<p>
   
   <a name="label332"></a>
   <pre class="jdocu_small" style="color: black">typedef enum {
        Sim_Break_Physical = 0,
        Sim_Break_Virtual  = 1,
        Sim_Break_Linear   = 2      /* x86 only */
} breakpoint_kind_t;</pre>
<p>
   
<p>
   The <i>access</i> argument is a bit-field setting the type of
   access. Any combination of the tree alternatives can be given (or'ed
   together).
<p>
   
   <a name="label333"></a>
   <pre class="jdocu_small" style="color: black">typedef enum {
        Sim_Access_Read = 1,
        Sim_Access_Write = 2,
        Sim_Access_Execute = 4
} access_t;</pre>
<p>
   
<p>
   The <i>address</i> is the start of the breakpoint range and
   <i>length</i> is its length in bytes. This range will be truncated
   as necessary to fit in the address space. An access intersecting the given
   range will trigger the breakpoint. If <i>length</i> is zero, the
   breakpoint range will be the entire address space.
<p>
   The <i>flags</i> argument should be passed a bitwise or of
   zero or more enumeration constants from 
   <tt>enum breakpoint_flag</tt>:
<p>
   <a name="label334"></a><a name="label335"></a>
   
<pre class="jdocu_small" style="color: black">enum breakpoint_flag {
        Sim_Breakpoint_Temporary = 1,
        Sim_Breakpoint_Simulation = 2,
        Sim_Breakpoint_Private = 4
};</pre>

<p>
   If the <tt>Sim_Breakpoint_Temporary</tt> bit is set, the breakpoint
   is automatically disabled when triggered the first time.
<p>
   If the <tt>Sim_Breakpoint_Simulation</tt> bit is set, the breakpoint
   will not show up in the <b>list-breakpoints</b> command, nor can it be
   removed by the <b>unbreak</b> command. Also, there will be no message
   printed on the Simics console when this breakpoint is triggered. This bit
   should be set when using breakpoints to simulate the target system; it
   will prevent Simics from temporarily disabling the breakpoint as an 
   optimization measure. This could otherwise happen during certain reverse
   execution operations.
<p>
   If the <tt>Sim_Breakpoint_Private</tt> bit is set, the breakpoint
   will not show up in the <b>list-breakpoints</b> command, nor can it be
   removed by the <b>unbreak</b> command. Also, there will be no message
   printed on the Simics console when this breakpoint is triggered.
<p>
   The default action for a triggered breakpoint is to return to the frontend
   (this can be changed  by using haps). On execution breakpoints Simics will return to
   the frontend before the instructions is executed, while instructions
   triggering read or write breakpoints will complete before control is
   returned to the frontend.
<p>
   Several breakpoints can be set on the same address and Simics will break on
   them in turn. If hap handlers are connected to the breakpoints they will
   also be executed in turn. Hap handlers are called before the access is
   performed, allowing the user to read a memory value that may be overwritten
   by the access. See the Simics Reference Manual for a description of hap
   handlers.
<p>
   Several attributes can be set for a breakpoint for breaking only when some
   conditions are true. See the <i>breakpoints</i> attribute in the
   <b>sim</b> class.
<p>
   This function returns the breakpoint id which is used for further reference
   to the breakpoint:
<p>
   <a name="label336"></a>
<pre class="jdocu_small" style="color: black">typedef int breakpoint_id_t;</pre>

<p>
   Breakpoints can be removed using <b><i>SIM_delete_breakpoint()</i></b>.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>General</b> Thrown if the type or access
   arguments are illegal.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Breakpoint id, -1 on exception.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label339">SIM_breakpoint_remove</a>, <a class="jdocu" href="#label342"> SIM_delete_breakpoint
   </a></dl>
<a name="label337"></a><h6 class="jdocu">SIM_breakpoint_remove()</h6 class="jdocu">

<a name="label338"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label339"></a><b>SIM_breakpoint_remove</b> &#8212; delete breakpoint range</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_breakpoint_remove(int id,
                      access_t access,
                      generic_address_t address,
                      generic_address_t length);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Deletes a breakpoint range from an existing breakpoint. Can thus be used to
   create holes in the breakpoint range. <i>id</i> is the breakpoint
   to operate on, as returned by <b><i>SIM_breakpoint()</i></b>. A value of zero
   will operate on all breakpoints that were not set using the
   <tt>Sim_Breakpoint_Simulation</tt> flag.
<p>
   <i>access</i> is a bitfield describing the type of breakpoint to
   remove using the enumeration constants of the <tt>access_t</tt> enum.
<p>
   <i>start</i> is the start address of the range and
   <i>length</i> is the length of the range in bytes.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>Index</b> Thrown if illegal breakpoint</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label331">SIM_breakpoint</a>, <a class="jdocu" href="#label342"> SIM_delete_breakpoint</a></dl>
<a name="label340"></a><h6 class="jdocu">SIM_delete_breakpoint()</h6 class="jdocu">

<a name="label341"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label342"></a><b>SIM_delete_breakpoint</b> &#8212; delete breakpoint</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_delete_breakpoint(breakpoint_id_t id);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Deletes breakpoint <i>id</i> as returned by
   <b><i>SIM_breakpoint()</i></b>. A value of zero will delete all breakpoints
   that were set without the <tt>Sim_Breakpoint_Simulation</tt> flag.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>Index</b> Thrown if no breakpoint with the id is found.</dd>
</dl>

<a name="label343"></a><h5 class="jdocu">Configuration</h5 class="jdocu">
<a name="label344"></a><h6 class="jdocu">SIM_add_configuration()</h6 class="jdocu">

<a name="label345"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label346"></a><b>SIM_add_configuration</b> &#8212; set configuration from Python</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_add_configuration(pre_conf_object_set_t *set, const char *file);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function is an alternative to reading the configuration from a file.
  A configuration is a sequence (list or tuple) of pre_conf_object Python
  objects, or a dictionary of the form {name : pre_conf_object}.
<p>
  The <i>file</i> argument in the name of the file that a configuration
  was read from, and should be set to None/NULL if not used.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>

  <b>General</b> Thrown if Simics fails to initialize all objects.
  </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label362">SIM_create_object</a></dl>
<a name="label347"></a><h6 class="jdocu">SIM_alloc_conf_object()</h6 class="jdocu">

<a name="label348"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label349"></a><b>SIM_alloc_conf_object</b> &#8212; allocate object</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">conf_object_t *
SIM_alloc_conf_object(parse_object_t *pa);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Allocate a new "bare" configuration object with no data members.
   This function is mainly for implementing classes in script languages.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>

    Returns the newly constructed object.
   </dd>
</dl>
<a name="label350"></a><h6 class="jdocu">SIM_attribute_error()</h6 class="jdocu">

<a name="label351"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label352"></a><b>SIM_attribute_error</b> &#8212; specify reason for attribute error</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_attribute_error(const char *msg);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
When used inside an attribute <b><i>set_attr</i></b>/<b><i>get_attr</i></b>
   method, indicates why it failed to set or retrieve the attribute.
   This function only serves to give an informative message to the user.
   The object or attribute names need not be mentioned in the
   <i>msg</i> argument; Simics will supply this automatically.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label438">SIM_register_typed_attribute</a></dl>
<a name="label353"></a><h6 class="jdocu">SIM_change_attribute_attribute()</h6 class="jdocu">

<a name="label354"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label355"></a><b>SIM_change_attribute_attribute</b> &#8212; change requiredness of attribute</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_change_attribute_attribute(conf_class_t *cls,
                               const char *name,
                               attr_attr_t attr);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function sets the attributes of an earlier registered
   attribute <i>name</i> in class <i>class_struct</i> to
   <i>attr</i>.
<p>
   <a name="label356"></a>
<pre class="jdocu_small" style="color: black">typedef enum {
        Sim_Attr_Required         = 0,
        Sim_Attr_Optional         = 1,

        Sim_Attr_Session          = 3,
        Sim_Attr_Pseudo           = 4,

        Sim_Attr_Flag_Mask        = 0xff,

        Sim_Init_Phase_Shift      = 8,
        Sim_Init_Phase_0          = 0 &lt;&lt; Sim_Init_Phase_Shift,
        Sim_Init_Phase_1          = 1 &lt;&lt; Sim_Init_Phase_Shift,

        Sim_Attr_Integer_Indexed  = 0x1000,
        Sim_Attr_String_Indexed   = 0x2000,
        Sim_Attr_List_Indexed     = 0x4000,
        
        Sim_Attr_Persistent       = 0x20000,

        /* set by SIM_register_*_attribute() */
        Sim_Attr_Read_Only        = 0x40000,
        Sim_Attr_Write_Only       = 0x80000

} attr_attr_t;</pre>
</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Returns zero if successful, and
   non-zero otherwise.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>General</b> Thrown if at least one
   argument is <tt>NULL</tt> or if the attribute
   <i>name</i> is not a valid attribute for the class with
   class structure <i>class_struct</i>.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label438">SIM_register_typed_attribute</a></dl>
<a name="label357"></a><h6 class="jdocu">SIM_class_has_attribute()</h6 class="jdocu">

<a name="label358"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label359"></a><b>SIM_class_has_attribute</b> &#8212; check if class implements attribute</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_class_has_attribute(conf_class_t *cls, const char *attr);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns 1 if the class <i>cl</i> implements an attribute with
   the name <i>attr</i></dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label438">SIM_register_typed_attribute</a>, <a class="jdocu" href="#label383">
   SIM_get_attribute</a></dl>
<a name="label360"></a><h6 class="jdocu">SIM_create_object()</h6 class="jdocu">

<a name="label361"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label362"></a><b>SIM_create_object</b> &#8212; create and initialise object</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">conf_object_t *
SIM_create_object(conf_class_t *cls, const char *name, attr_value_t attrs);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Creates a new instance of the configuration class <i>cls</i>.
   <i>name</i> must consist of a letter followed by letters, digits,
   hyphens (<tt>-</tt>) or underscores (<tt>_</tt>). Hyphens and underscores
   are equivalent, so <tt>ben_hur</tt> and <tt>ben-hur</tt> refer to the
   same object.
<p>
   The new object is initialised with attributes from <i>attrs</i>, which
   must be a list of (<i>attribute-name</i>, <i>value</i>) pairs as two-element
   lists. All required attributes for the class <i>cl</i> must be present
   in <i>attrs</i>.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The new object, or <tt>NULL</tt> on
   error (in which case an exception is raised).</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>General</b> Thrown if either argument is
   <tt>NULL</tt>, the name is not well-formed, if an object named
   <i>name</i> already exists, or if the initialisation failed.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label449">SIM_set_configuration</a></dl>
<a name="label363"></a><h6 class="jdocu">SIM_delete_object()</h6 class="jdocu">

<a name="label364"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label365"></a><b>SIM_delete_object</b> &#8212; delete object</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_delete_object(conf_object_t *obj);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Deletes an object. The caller should make sure that there are no
   references to the object being deleted, and that there are no pending
   events associated with the object (all such events will be removed
   from the event queue automatically).</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Returns zero if successful. Throws an
   exception and returns non-zero otherwise.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>General</b> Thrown if the associated class does
   not support object deletion (has no destructor).</dd>
</dl>
<a name="label366"></a><h6 class="jdocu">SIM_ensure_partial_attr_order()</h6 class="jdocu">

<a name="label367"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label368"></a><b>SIM_ensure_partial_attr_order</b> &#8212; ensure attribute order</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_ensure_partial_attr_order(conf_class_t *cls, const char *attr1,
                              const char *attr2);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Attribute initialization order is guaranteed to be identical to the order
   in which the attributes were registered. In some cases a particular order
   is required in order for a model to work correctly.
<p>
   This function checks the registration order of <i>attr1</i>
   and <i>attr2</i> in the class <i>cls</i>. If
   <i>attr1</i> is not registered before <i>attr2</i>, or if
   at least one of the two are not registered at all, an ASSERT is triggered.
<p>
   Use this function to ensure that e.g. code refactoring does not break
   a required attribute order.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label438">SIM_register_typed_attribute</a></dl>
<a name="label369"></a><h6 class="jdocu">SIM_free_attribute()</h6 class="jdocu">

<a name="label370"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label371"></a><b>SIM_free_attribute</b> &#8212; free attribute</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_free_attribute(attr_value_t value);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Attributes returned by <b><i>SIM_get_attribute()</i></b> should be freed using
   this function. It doesn't actually do anything for values of a different
   kind than <tt>Sim_Val_List</tt> or <tt>Sim_Val_Dict</tt>.
<p>
   When called with a <tt>Sim_Val_List</tt> argument, it calls
   <b><i>SIM_free_attribute()</i></b> on each element of the list before freeing
   the list itself.</dd>

<p>
</dl>
<a name="label372"></a><h6 class="jdocu">SIM_get_all_classes()</h6 class="jdocu">

<a name="label373"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label374"></a><b>SIM_get_all_classes</b> &#8212; get list of all classes</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">attr_value_t
SIM_get_all_classes(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return a list of the names of all configuration classes.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
List of class names.</dd>
</dl>
<a name="label375"></a><h6 class="jdocu">SIM_get_all_objects()</h6 class="jdocu">

<a name="label376"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label377"></a><b>SIM_get_all_objects</b> &#8212; get list of all objects</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">attr_value_t
SIM_get_all_objects(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return a list of all configuration objects.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
List of objects.</dd>
</dl>
<a name="label378"></a><h6 class="jdocu">SIM_get_attribute()</h6 class="jdocu">

<a name="label379"></a><a name="label380"></a><a name="label381"></a><a name="label382"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label383"></a><b>SIM_get_attribute</b><b>, SIM_get_class_attribute</b><b>, SIM_get_attribute_idx</b><b>, SIM_get_class_attribute_idx</b> &#8212; get attribute</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">attr_value_t
SIM_get_attribute(conf_object_t *obj, const char *name);
</pre><pre class="jdocu_small" style="color: black">attr_value_t
SIM_get_class_attribute(conf_class_t *cls, const char *name);
</pre><pre class="jdocu_small" style="color: black">attr_value_t
SIM_get_attribute_idx(conf_object_t *obj, const char *name,
                      attr_value_t *index);
</pre><pre class="jdocu_small" style="color: black">attr_value_t
SIM_get_class_attribute_idx(conf_class_t *cls, const char *name,
                            attr_value_t *index);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Extracts the attribute specified by the <i>name</i> parameter
   from <i>obj</i>. When the caller has finished using the attribute
   value, it should be freed using free_attribute. If an error occurs,
   or if the attribute is not defined for the given object, then the
   returned value will be of type Sim_Val_Invalid. The _idx version of the
   function can be used to get a single entry in a list or data
   attribute. The attribute must support indexing, for this to work.
<p>
   Return values of kind <tt>Sim_Val_List</tt> or
   <tt>Sim_Val_Dict</tt> have to be freed using
   <b><i>SIM_free_attribute()</i></b>.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Attribute value. The kind field in the
   returned structure is <tt>Sim_Val_Invalid</tt> if the attribute could
   not be found.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>General</b> If either argument is NULL.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label371">SIM_free_attribute</a>, <a class="jdocu" href="#label445"> SIM_set_attribute</a></dl>
<a name="label384"></a><h6 class="jdocu">SIM_get_attribute_attributes()</h6 class="jdocu">

<a name="label385"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label386"></a><b>SIM_get_attribute_attributes</b> &#8212; get attribute flags</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">attr_attr_t
SIM_get_attribute_attributes(conf_class_t *cls, const char *attr);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the attribute flags of the <i>attr</i> attribute of the
   configuration object <i>obj</i>.
<p>
   <b><i>SIM_get_attribute_attributes()</i></b> with an object as parameter is
   deprecated since Simics 3.0.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label438">SIM_register_typed_attribute</a>, <a class="jdocu" href="#label355">
   SIM_change_attribute_attribute</a></dl>
<a name="label387"></a><h6 class="jdocu">SIM_get_class()</h6 class="jdocu">

<a name="label388"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label389"></a><b>SIM_get_class</b> &#8212; get class</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">conf_class_t *
SIM_get_class(const char *name);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the configuration class called <i>name</i>.
   <a name="label390"></a></dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Opaque pointer referencing the class,
   or NULL if not found.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>General</b> Thrown if the class has not been registered or if <i>name</i> is NULL.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label393">SIM_get_class_name</a></dl>
<a name="label391"></a><h6 class="jdocu">SIM_get_class_name()</h6 class="jdocu">

<a name="label392"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label393"></a><b>SIM_get_class_name</b> &#8212; get class name</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">const char *
SIM_get_class_name(const conf_class_t *class_data);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the name of the class</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label389">SIM_get_class</a></dl>
<a name="label394"></a><h6 class="jdocu">SIM_get_configuration_file_prefix()</h6 class="jdocu">

<a name="label395"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label396"></a><b>SIM_get_configuration_file_prefix</b> &#8212; get filename prefix</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">const char *
SIM_get_configuration_file_prefix(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
An object that wants to create a file as part of an attribute value
   should request a filename prefix using this function. The
   <i>image</i> class uses this feature to store memory in a separate
   file.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Null-terminated prefix string, or NULL
   if called outside a configuration.</dd>
</dl>
<a name="label397"></a><h6 class="jdocu">SIM_get_interface()</h6 class="jdocu">

<a name="label398"></a><a name="label399"></a><a name="label400"></a><a name="label401"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label402"></a><b>SIM_get_interface</b><b>, SIM_get_class_interface</b><b>, SIM_get_port_interface</b><b>, SIM_get_class_port_interface</b> &#8212; get interface</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void *
SIM_get_interface(const conf_object_t *obj, const char *name);
</pre><pre class="jdocu_small" style="color: black">void *
SIM_get_class_interface(const conf_class_t *cls, const char *name);
</pre><pre class="jdocu_small" style="color: black">void *
SIM_get_port_interface(const conf_object_t *obj, const char *name,
                       const char *portname);
</pre><pre class="jdocu_small" style="color: black">void *
SIM_get_class_port_interface(const conf_class_t *cls,
                              const char *name, const char *portname);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Get the interface with name <i>name</i> from object
   <i>obj</i>. Returns NULL, and raises an exception if
   <i>obj</i> does not implement the interface.
<p>
   <b><i>SIM_get_port_interface()</i></b> returns an port interface
   instance as registered with
   <b><i>SIM_register_port_interface()</i></b>. The
   <i>portname</i> selects a particular implementation of the
   interface by <i>obj's</i> class. If no instance name is supplied,
   the function behaves as <b><i>SIM_get_interface()</i></b>.
<p>
   If a class only defines a single port interface, it may be looked up using
   <b><i>SIM_get_interface()</i></b> as well.
<p>
   <b><i>SIM_get_class_interface</i></b> and
   <b><i>SIM_get_class_port_interface</i></b> are similar but return the
   interface for a class instead of an object.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>

   Pointer to interface, or NULL if not found.
   </dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>Lookup</b> Thrown if the
   interface is not implemented by <i>obj's</i> class.<br>
   <b>General</b> Thrown if the interface name is illegal.
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label434">SIM_register_interface</a>, 
   SIM_register_port_interface
   </dl>
<a name="label403"></a><h6 class="jdocu">SIM_get_object()</h6 class="jdocu">

<a name="label404"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label405"></a><b>SIM_get_object</b> &#8212; get object</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">conf_object_t *
SIM_get_object(const char *name);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the object with name <i>name</i>.
   
<pre class="jdocu_small" style="color: black">struct conf_object {
        conf_class_t *class_data;  /* class data */
        const char *name;          /* instance name */
        struct conf_object *queue; /* queue */
        lang_void *object_data;    /* internal to class implementation */
        int object_id;             /* deprecated, do not use */
        int configured;            /* set when configuration ready */
};</pre>

<pre class="jdocu_small" style="color: black">typedef struct conf_object conf_object_t;</pre>
</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Pointer to object, or NULL if not found.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>General</b>Thrown if the object can not be found or if <i>name</i> is NULL.</dd>
</dl>
<a name="label406"></a><h6 class="jdocu">SIM_initial_configuration_ok()</h6 class="jdocu">

<a name="label407"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label408"></a><b>SIM_initial_configuration_ok</b> &#8212; get configuration status</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_initial_configuration_ok(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns non-zero if a configuration has been loaded into Simics
   (e.g., using <b>read-configuration</b>), or zero otherwise.</dd>

<p>
</dl>
<a name="label409"></a><h6 class="jdocu">SIM_new_object()</h6 class="jdocu">

<a name="label410"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label411"></a><b>SIM_new_object</b> &#8212; create object</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">conf_object_t *
SIM_new_object(conf_class_t *cls, const char *name);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Creates a new instance of the configuration class <i>the_class</i>.
   <i>name</i> must consist of a letter followed by letters,
   digits, hyphens (<tt>-</tt>) or underscores (<tt>_</tt>). Hyphens and
   underscores are equivalent, so <tt>ben_hur</tt> and <tt>ben-hur</tt> refer
   to the same object.
<p>
   <hr class="jdocu_note"><b>Note:</b>  This function is <b>deprecated</b>. It can only safely be used to
   create objects that have no required attributes or no finalisation method.
   In other cases, <b><i>SIM_create_object</i></b> or
   <b><i>SIM_set_configuration</i></b> must be used. <hr class="jdocu_note"></dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Pointer to new object, or
   <tt>NULL</tt> on error (in which case an exception is
   raised).</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>General</b> Thrown if either
   argument is <tt>NULL</tt>, if no configuration has been
   loaded, or if an object with name <i>name</i> already
   exists.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label362">SIM_create_object</a>, <a class="jdocu" href="#label449"> SIM_set_configuration
   </a></dl>
<a name="label412"></a><h6 class="jdocu">SIM_object_constructor()</h6 class="jdocu">

<a name="label413"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label414"></a><b>SIM_object_constructor</b> &#8212; base class constructor</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_object_constructor(conf_object_t *obj, parse_object_t *pobj);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This constructor should be called by <b><i>new_instance</i></b>
   functions (see the <tt>class_data_t</tt> structure) to
   initialize a new object. If the new object is a
   <tt>log_object_t</tt>, the <b><i>SIM_log_constructor()</i></b>
   function should be used instead.</dd>

<p>
</dl>
<a name="label415"></a><h6 class="jdocu">SIM_object_is_processor()</h6 class="jdocu">

<a name="label416"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label417"></a><b>SIM_object_is_processor</b> &#8212; test if object is a processor</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_object_is_processor(conf_object_t *obj);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns non-zero if <i>obj</i> is a processor.</dd>

<p>
</dl>
<a name="label418"></a><h6 class="jdocu">SIM_read_configuration()</h6 class="jdocu">

<a name="label419"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label420"></a><b>SIM_read_configuration</b> &#8212; read configuration</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_read_configuration(const char *file);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Read configuration from <i>filename</i> and create a machine accordingly.
   Can only be issued once per session. This function will exit the simulator
   on certain error conditions (such as license violations).</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>General</b> Thrown if the file could not be
   opened, the machine was already initialized, or if an error in the
   configuration file was detected.
   </dd>
</dl>
<a name="label421"></a><h6 class="jdocu">SIM_register_attribute()</h6 class="jdocu">

<a name="label422"></a><a name="label423"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label424"></a><b>SIM_register_attribute</b><b>, SIM_register_class_attribute</b> &#8212; register attribute</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_register_attribute(
        conf_class_t *cls, const char *name,
        attr_value_t (*get_attr)(lang_void *user_data,
                                 conf_object_t *obj,
                                 attr_value_t *idx),
        lang_void *user_data_get,
        set_error_t (*set_attr)(lang_void *user_data,
                                conf_object_t *obj,
                                attr_value_t *val, attr_value_t *idx),
        lang_void *user_data_set,
        attr_attr_t attr,
        const char *desc);
</pre><pre class="jdocu_small" style="color: black">int
SIM_register_class_attribute(
        conf_class_t *cls, const char *name,
        attr_value_t (*get_attr)(lang_void *ptr,
                                 conf_class_t *c,
                                 attr_value_t *idx),
        lang_void *user_data_get,
        set_error_t (*set_attr)(lang_void *ptr,
                                conf_class_t *c,
                                attr_value_t *val, attr_value_t *idx),
        lang_void *user_data_set,
        attr_attr_t attr,
        const char *desc);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions are deprecated, use
   <b><i>SIM_register_typed_attribute()</i></b> and
   <b><i>SIM_register_typed_class_attribute()</i></b> instead.</dd>

<p>
</dl>
<a name="label425"></a><h6 class="jdocu">SIM_register_class()</h6 class="jdocu">

<a name="label426"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label427"></a><b>SIM_register_class</b> &#8212; register class</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">conf_class_t *
SIM_register_class(const char *name,
                   class_data_t *class_data);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function registers a new class that can be instantiated by
   calling the <b><i>SIM_create_object</i></b> function.
<p>
   <i>class_data</i> may be freed when the function has returned.
   
   
<pre class="jdocu_small" style="color: black">typedef enum {
        Sim_Class_Kind_Vanilla, /* object is saved at checkpoints */
        Sim_Class_Kind_Session, /* object is saved as part of a
                                 * session only */
        Sim_Class_Kind_Pseudo   /* object is never saved */
} class_kind_t;</pre>

   
<pre class="jdocu_small" style="color: black">typedef struct class_data {
        conf_object_t *(*new_instance)(parse_object_t *parse_obj);
        int (*delete_instance)(conf_object_t *obj);
        void (*finalize_instance)(conf_object_t *obj);
        attr_value_t (*default_get_attr)(const char *name,
                                         conf_object_t *obj,
                                         attr_value_t *idx);
        set_error_t (*default_set_attr)(const char *name,
                                        conf_object_t *obj,
                                        attr_value_t *val,
                                        attr_value_t *idx);
        conf_class_t         *parent;
        const char           *description;
        class_kind_t          kind;
} class_data_t;</pre>

<p>
   The <i>new_instance</i> function should return a newly
   allocated object. The object must begin with a <tt>conf_object_t</tt>
   structure which should be initialized with the object_constructor
   function.
<p>
   <i>delete_instance</i> must be <tt>NULL</tt> if the class
   does not support object deletion.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Class structure, or
   <tt>NULL</tt> on error.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>General</b> Thrown if either the
   <i>name</i> or the <i>class_data</i> argument is
   <tt>NULL</tt>.<br>
<p>
   <b>Attribute</b> If the <i>class_data</i> structure does not
   include a new_instance function.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label414">SIM_object_constructor</a>, <a class="jdocu" href="#label430"> SIM_register_class_alias</a></dl>
<a name="label428"></a><h6 class="jdocu">SIM_register_class_alias()</h6 class="jdocu">

<a name="label429"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label430"></a><b>SIM_register_class_alias</b> &#8212; register class alias</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_register_class_alias(const char *alias,
                         const char *name);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Register a new class alias <i>alias</i> for the already registered
   class <i>class_name</i>. Using aliases allows the
   <i>read-configuration</i> command to read configuration files that
   define objects of type <i>alias</i>, while the
   <i>write-configuration</i> command always uses <i>class_name</i>.
<p>
   Aliases are used to support compatibility with old class names if a
   class is renamed. They can also be used to allow different modules,
   which define different specific implementations of the same generic
   base class, to read the same configuration files.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label427">SIM_register_class</a></dl>
<a name="label431"></a><h6 class="jdocu">SIM_register_interface()</h6 class="jdocu">

<a name="label432"></a><a name="label433"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label434"></a><b>SIM_register_interface</b><b>, SIM_register_port_interface</b> &#8212; register interface</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_register_interface(conf_class_t *cls, const char *name, void *iface);
</pre><pre class="jdocu_small" style="color: black">int
SIM_register_port_interface(conf_class_t *cls, const char *name,
                            void *iface, const char *portname,
                            const char *desc);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Register that <i>cl</i> implements the <i>name</i>
   interface. The interface itself should be supplied in the
   <i>iface</i> argument.
<p>
   <b><i>SIM_register_port_interface()</i></b> registers a port instance of
   an interface that must be looked up using
   <b><i>SIM_get_port_interface</i></b>. The port name may not be the same
   as any attribute name used by the class.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Returns non-zero on failure, 0 otherwise.
   </dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>

   <b>General</b> Thrown if the interface name is illegal.
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label402">SIM_get_interface</a>,  SIM_get_port_interface
   </dl>
<a name="label435"></a><h6 class="jdocu">SIM_register_typed_attribute()</h6 class="jdocu">

<a name="label436"></a><a name="label437"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label438"></a><b>SIM_register_typed_attribute</b><b>, SIM_register_typed_class_attribute</b> &#8212; register attribute</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_register_typed_attribute(
        conf_class_t *cls, const char *name,
        attr_value_t (*get_attr)(lang_void *user_data,
                                 conf_object_t *obj,
                                 attr_value_t *idx),
        lang_void *user_data_get,
        set_error_t (*set_attr)(lang_void *user_data,
                                conf_object_t *obj,
                                attr_value_t *val, attr_value_t *idx),
        lang_void *user_data_set,
        attr_attr_t attr, const char *type, const char *idx_type,
        const char *desc);
</pre><pre class="jdocu_small" style="color: black">int
SIM_register_typed_class_attribute(
        conf_class_t *cls, const char *name,
        attr_value_t (*get_attr)(lang_void *ptr,
                                 conf_class_t *c,
                                 attr_value_t *idx),
        lang_void *user_data_get,
        set_error_t (*set_attr)(lang_void *ptr,
                                conf_class_t *c,
                                attr_value_t *val,
                                attr_value_t *idx),
        lang_void *user_data_set,
        attr_attr_t attr, const char *type, const char *idx_type,
        const char *desc);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Add the attribute <i>name</i> to the set of attributes
   understood by the <i>cls</i> class.
<p>
   The function <i>get_attr</i> is called with the object and the
   supplied data in <i>user_data_get</i> as arguments, and
   returns the current value of the attribute. It may return a value of type
   <tt>Sim_Val_Invalid</tt> if the argument has no sensible value. Lists
   and other compound data structures should be allocated dynamically by
   <i>get_attr</i>. If <i>get_attr</i> is a null pointer, the attribute
   will be write-only.
<p>
   After the initial configuration, <i>set_attr</i> may be called at any
   time to change the value of an attribute. Compound data structures should be
   copied if <i>set_attr</i> wants to keep them. If <i>set_attr</i> is
   a null pointer, the attribute will be read-only.
<p>
   All attributes that are marked <tt>Sim_Attr_Required</tt>
   must be present in all configurations.
<p>
   <a name="label439"></a>
<pre class="jdocu_small" style="color: black">typedef enum {
        Sim_Attr_Required         = 0,
        Sim_Attr_Optional         = 1,

        Sim_Attr_Session          = 3,
        Sim_Attr_Pseudo           = 4,

        Sim_Attr_Flag_Mask        = 0xff,

        Sim_Init_Phase_Shift      = 8,
        Sim_Init_Phase_0          = 0 &lt;&lt; Sim_Init_Phase_Shift,
        Sim_Init_Phase_1          = 1 &lt;&lt; Sim_Init_Phase_Shift,

        Sim_Attr_Integer_Indexed  = 0x1000,
        Sim_Attr_String_Indexed   = 0x2000,
        Sim_Attr_List_Indexed     = 0x4000,
        
        Sim_Attr_Persistent       = 0x20000,

        /* set by SIM_register_*_attribute() */
        Sim_Attr_Read_Only        = 0x40000,
        Sim_Attr_Write_Only       = 0x80000

} attr_attr_t;</pre>

<p>
   To make the set_attr function easier to write, Simics provides a simple type
   system for attributes. You can provide typing information for both simple
   and indexed access to the attribute via the <i>type</i> and
   <i>idx_type</i> attributes (note that, in the latter case, you specify
   the type of the attribute for indexed access, <em>not</em> the type of the
   index). Setting either parameter to <tt>NULL</tt> will prevent
   typechecking for that access mode (normal or indexed).
<p>
   A type is described by a string composed with the following rules:
<p>
   <ul>
<p>
   <li>A simple type is represented by a single letter: <i>i</i>
   (integer), <i>f</i> (floating), <i>s</i> (string), <i>d</i> (data),
   <i>o</i> (object), <i>b</i> (boolean), <i>D</i> (dictionary), <i>n</i> (nil)
   or <i>a</i> (all).</li>
<p>
   <li>You can match several types by using the operator '|' like in
   s|o (string OR object). Note that if you provide a string when an
   object is expected, Simics will call <b><i>SIM_get_object()</i></b> to
   try to translate the string into a valid object.</li>
<p>
   <li>Lists are defined by square brackets: [ and ]. Lists can be
   specified in two ways:
<p>
      <ul>
<p>
      <li>Lists with a fixed amount of arguments: [iffsf] matches
      (integer, floating, floating, string, floating).</li>
<p>
      <li>lists with a size specifier: [i*] matches any list
      containing only integers (even []); [i+] matches any list
      containing only integers (but not []); [i{1:4}] matches lists of
      integers with 1 to 4 elements; [i{4}] is the same as [i{4:4}],
      i.e. a list of four integers. When you specify a size, the list
      definition can have only one element.</li>
<p>
      </ul>
<p>
   </li>
<p>
   <li>| has higher precedence than concatenation in list description, i.e,
   [i|si|s] should be read [i|s,i|s] which matches any two-element list with
   integer or string elements. For clarity you can use ',' wherever you want in
   the type definition, it will be ignored.</li>
<p>
   </ul></dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Returns zero if successful, and
   non-zero otherwise.</dd>
<dt class="jdocu_descitem">NOTE</dt><dd>
During initial configuration (with the
   read-configuration command), attribute values will be set in the
   same order as they are registered.</dd>
</dl>
<a name="label440"></a><h6 class="jdocu">SIM_set_attribute()</h6 class="jdocu">

<a name="label441"></a><a name="label442"></a><a name="label443"></a><a name="label444"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label445"></a><b>SIM_set_attribute</b><b>, SIM_set_class_attribute</b><b>, SIM_set_attribute_idx</b><b>, SIM_set_class_attribute_idx</b> &#8212; set attribute</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">set_error_t
SIM_set_attribute(conf_object_t *obj,
                  const char *name,
                  attr_value_t *value);
</pre><pre class="jdocu_small" style="color: black">set_error_t
SIM_set_class_attribute(conf_class_t *cls,
                        const char *name,
                        attr_value_t *value);
</pre><pre class="jdocu_small" style="color: black">set_error_t
SIM_set_attribute_idx(conf_object_t *obj,
                      const char *name,
                      attr_value_t *index,
                      attr_value_t *value);
</pre><pre class="jdocu_small" style="color: black">set_error_t
SIM_set_class_attribute_idx(conf_class_t *cls,
                            const char *name,
                            attr_value_t *index,
                            attr_value_t *value);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Set the <i>name</i> attribute in <i>obj</i> to <i>value</i>.
<p>
   The <tt>_idx</tt> version of the function can be used to get a
   single entry in a list or data attribute. For this to work, the
   attribute must support indexing.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The return value is from the
   <tt>set_error_t</tt> enum, with <tt>Sim_Set_Ok</tt> indicating
   success.<a name="label446"></a></dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label383">SIM_get_attribute</a>, <a class="jdocu" href="topic7.html#label159"> set_error_t</a></dl>
<a name="label447"></a><h6 class="jdocu">SIM_set_configuration()</h6 class="jdocu">

<a name="label448"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label449"></a><b>SIM_set_configuration</b> &#8212; set configuration from data</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_set_configuration(attr_value_t conf);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<hr class="jdocu_note"><b>Note:</b> It is recommended that the <b><i>SIM_add_configuration</i></b> function is
  used instead of <b><i>SIM_set_configuration</i></b>.<hr class="jdocu_note">
<p>
  This function is an alternative to reading the configuration
  from a file. A configuration is an <tt>attr_value_t</tt>
  which should have the following structure.
<p>
  <span class="jdocu_smaller"><pre class="jdocu_small" style="color: black">
  (("name", "class",  ("attr_name", attr_val) ... ), ... )
  </pre></span>
<p>
  That is a list of object specifiers containing name, class,
  and a list of attribute specifiers. An attribute specifier is
  a list of length 2 containing the attribute name and its
  value. <b><i>SIM_set_configuration()</i></b> allows an easy way
  of parameterizing the configuration, especially if called from
  Python.</dd>

<p>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
The following is an Python example:
<p>
  <span class="jdocu_small">
  <pre class="jdocu_small" style="color: black">
  from configuration import *

  SIM_set_configuration([
   ["cpu0", "x86",
    ["queue", OBJ("cpu0")],
    ["freq_mhz", 20],
    ["physical_memory", OBJ("phys_mem0")]],

   ["phys_mem0", "memory-space",
    ["map",  [[0xa0000,    OBJ("vga0"),    1, 0, 0x20000],
              [0x00000,    OBJ("mem0"),    0, 0x00000, 0xA0000],
              [0xc0000,    OBJ("mem0"),    0, 0xc0000, 0x8000],
              [0xc8000,    OBJ("setmem0"), 0, 0, 0x28000],
              [0xf0000,    OBJ("mem0"),    0, 0xf0000, 0x10000],
              [0x100000,   OBJ("mem0"),    0, 0x100000, 0x3ff00000],
              [0xfee00000, OBJ("apic0"),   0, 0, 0x4000]]]],
      ... ])
  </pre>
  </span>
  </dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>

  <b>Attribute</b> Thrown if malformed configuration list.<br>
  <b>General</b> Thrown if Simics fails to initialize all objects.
  </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label346">SIM_add_configuration</a>, <a class="jdocu" href="#label362"> SIM_create_object</a></dl>
<a name="label450"></a><h6 class="jdocu">SIM_write_configuration_to_file()</h6 class="jdocu">

<a name="label451"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label452"></a><b>SIM_write_configuration_to_file</b> &#8212; write configuration</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_write_configuration_to_file(const char *file);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Saves all objects to the configuration file
   <i>filename</i>. Objects whose <tt>class_kind_t</tt> is equal to
   <tt>Sim_Class_Kind_Session</tt> or <tt>Sim_Class_Kind_Pseudo</tt> are not saved. This also
   holds for attributes (in all objects) of types Sim_Attr_Session and
   Sim_Attr_Pseudo.
<p>
   Classes that wish to create additional files can
   use the <b><i>SIM_get_configuration_file_prefix</i></b> call to get a
   suitable filename prefix.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
0 if successful, 1 otherwise.</dd>
</dl>

<a name="label453"></a><h5 class="jdocu">Documentation</h5 class="jdocu">
<a name="label454"></a><h6 class="jdocu">SIM_register_copyright()</h6 class="jdocu">

<a name="label455"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label456"></a><b>SIM_register_copyright</b> &#8212; register copyright information</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_register_copyright(const char *str);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This registers specific copyright information related to an extension
   module or similar component of Simics. The Simics front-end command
   "copyright" will list, in addition to Simics copyright notices, any
   registered notices from libraries or plug-ins that have added a string
   using this function.
<p>
   The string should contain only standard ASCII characters, be pre-formatted
   for at most 80-character width terminal, be non-indented, and have
   no spurious new-line characters before or after the last line (except
   for the new-line that marks the end of the last line).
<p>
   The string will not be copied so needs to be either static or
   a copy generated by the callee (preferably static).</dd>

<p>
</dl>
<a name="label457"></a><h6 class="jdocu">SIM_version()</h6 class="jdocu">

<a name="label458"></a><a name="label459"></a><a name="label460"></a><a name="label461"></a><a name="label462"></a><a name="label463"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label464"></a><b>SIM_version</b><b>, SIM_version_sub</b><b>, SIM_readme</b><b>, SIM_snapshot_date</b><b>, SIM_license</b><b>, SIM_copyright</b> &#8212; get version info about Simics</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">const char *
SIM_version(void);
</pre><pre class="jdocu_small" style="color: black">const char *
SIM_version_sub(void);
</pre><pre class="jdocu_small" style="color: black">const char *
SIM_readme(void);
</pre><pre class="jdocu_small" style="color: black">const char *
SIM_snapshot_date(void);
</pre><pre class="jdocu_small" style="color: black">void
SIM_license(void);
</pre><pre class="jdocu_small" style="color: black">void
SIM_copyright(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return strings describing the version of Simics, compile date,
   expiry date, license and a general readme.</dd>

<p>
</dl>

<a name="label465"></a><h5 class="jdocu">Errors and Exceptions</h5 class="jdocu">
<a name="label466"></a><h6 class="jdocu">SIM_clear_exception()</h6 class="jdocu">

<a name="label467"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label468"></a><b>SIM_clear_exception</b> &#8212; clear pending exception</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">sim_exception_t
SIM_clear_exception(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Clears the current pending exception.
<p>
   <tt>SimExc_No_Exception</tt> if none available.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Returns the exception that was pending before the call,
   or <tt>SimExc_No_Exception</tt> if none.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label476">SIM_frontend_exception</a>, <a class="jdocu" href="#label479"> SIM_get_pending_exception</a></dl>
<a name="label469"></a><h6 class="jdocu">SIM_command_has_problem()</h6 class="jdocu">

<a name="label470"></a><a name="label471"></a><a name="label472"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label473"></a><b>SIM_command_has_problem</b><b>, SIM_command_clear_problem</b><b>, SIM_command_problem_status</b> &#8212; signal error in command</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_command_has_problem(void);
</pre><pre class="jdocu_small" style="color: black">void
SIM_command_clear_problem(void);
</pre><pre class="jdocu_small" style="color: black">int
SIM_command_problem_status(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Call this function if the currently executing command, created with the python
   function new_command(), is having a problem. Examples of problems are
   illegal parameters, syntax error, serious error in carrying out
   command, etc. One of the effects is to stop any enclosing
   structure, such as a script file, from continuing.
<p>
   The current problem status can be queried with
   SIM_command_problem_status where a return value of zero means no
   problem. The status can be cleared by calling
   SIM_command_clear_problem(), allowing script files to continue
   executing.</dd>

<p>
</dl>
<a name="label474"></a><h6 class="jdocu">SIM_frontend_exception()</h6 class="jdocu">

<a name="label475"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label476"></a><b>SIM_frontend_exception</b> &#8212; raise an exception</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_frontend_exception(sim_exception_t exc_type, const char *str);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function raises an exception of type <i>exc_type</i> and
   message <i>str</i>.
<p>
   The state of the pending exception can be read with
   <b><i>SIM_get_pending_exception()</i></b> and cleared with
   <b><i>SIM_clear_exception()</i></b>.</dd>

<p>
</dl>
<a name="label477"></a><h6 class="jdocu">SIM_get_pending_exception()</h6 class="jdocu">

<a name="label478"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label479"></a><b>SIM_get_pending_exception</b> &#8212; get current pending exception</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">sim_exception_t
SIM_get_pending_exception(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function returns the exception type of the current pending exception, or 
   <tt>SimExc_No_Exception</tt> if none available.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label476">SIM_frontend_exception</a>, <a class="jdocu" href="#label468"> SIM_clear_exception</a>, <a class="jdocu" href="#label482"> SIM_last_error</a></dl>
<a name="label480"></a><h6 class="jdocu">SIM_last_error()</h6 class="jdocu">

<a name="label481"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label482"></a><b>SIM_last_error</b> &#8212; get error message from last exception</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">const char *
SIM_last_error(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the error message attached to the last exception raised.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label476">SIM_frontend_exception</a></dl>

<a name="label483"></a><h5 class="jdocu">Haps</h5 class="jdocu">
<a name="label484"></a><h6 class="jdocu">SIM_c_hap_occurred()</h6 class="jdocu">

<a name="label485"></a><a name="label486"></a><a name="label487"></a><a name="label488"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label489"></a><b>SIM_c_hap_occurred</b><b>, SIM_c_hap_occurred_vararg</b><b>, SIM_c_hap_occurred_always</b><b>, SIM_c_hap_occurred_always_vararg</b> &#8212; trigger a hap occurrence</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_c_hap_occurred(hap_type_t hap, conf_object_t *obj,
                   integer_t value, ...);
</pre><pre class="jdocu_small" style="color: black">int
SIM_c_hap_occurred_vararg(hap_type_t hap, conf_object_t *obj,
                          integer_t value, va_list ap);
</pre><pre class="jdocu_small" style="color: black">int
SIM_c_hap_occurred_always(hap_type_t hap, conf_object_t *obj,
                          integer_t value, ...);
</pre><pre class="jdocu_small" style="color: black">int
SIM_c_hap_occurred_always_vararg(hap_type_t hap, conf_object_t *obj,
                                 integer_t value, va_list ap);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions are used to cause a hap of type <tt>hap</tt>. The
   <tt>value</tt> argument is used for checking ranges. The
   hap-specific data is passed as the first parameter to the callback
   function (see <b><i>SIM_hap_add_callback()</i></b>).
   These functions return the number of callbacks that were called.
<p>
   <b><i>SIM_hap_occurred()</i></b> will only run callback functions for a
   specific hap once per simulated cycle. The
   <b><i>SIM_hap_occurred_always()</i></b> function will always run the
   callbacks.
<p>
   The functions <b><i>SIM_c_hap_occurred_vararg()</i></b> and
   <b><i>SIM_c_hap_occurred_always_vararg()</i></b> are vararg versions
   of these functions.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>Break</b> Thrown if a callback requested the
   simulation to stop. This exception will be removed in a future Simics
   version. Do not write new code relying on it.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The number of callback functions
   called.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label787">SIM_break_simulation</a></dl>
<a name="label490"></a><h6 class="jdocu">SIM_get_all_hap_types()</h6 class="jdocu">

<a name="label491"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label492"></a><b>SIM_get_all_hap_types</b> &#8212; get list of all hap types</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">attr_value_t
SIM_get_all_hap_types(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Get data structure with the names of all hap types.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
List with strings.
   </dd>
</dl>
<a name="label493"></a><h6 class="jdocu">SIM_hap_add_callback()</h6 class="jdocu">

<a name="label494"></a><a name="label495"></a><a name="label496"></a><a name="label497"></a><a name="label498"></a><a name="label499"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label500"></a><b>SIM_hap_add_callback</b><b>, SIM_hap_add_callback_index</b><b>, SIM_hap_add_callback_range</b><b>, SIM_hap_add_callback_obj</b><b>, SIM_hap_add_callback_obj_index</b><b>, SIM_hap_add_callback_obj_range</b> &#8212; install callback on a hap</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">hap_handle_t
SIM_hap_add_callback(const char *hap,
                     obj_hap_func_t func,
                     typed_lang_void *user_data);
</pre><pre class="jdocu_small" style="color: black">hap_handle_t
SIM_hap_add_callback_index(const char *hap,
                           obj_hap_func_t func,
                           typed_lang_void *user_data,
                           integer_t index);
</pre><pre class="jdocu_small" style="color: black">hap_handle_t
SIM_hap_add_callback_range(const char *hap,
                           obj_hap_func_t func,
                           typed_lang_void *user_data,
                           integer_t start,
                           integer_t end);
</pre><pre class="jdocu_small" style="color: black">hap_handle_t
SIM_hap_add_callback_obj(const char *hap,
                         conf_object_t *obj,
                         hap_flags_t flags,
                         obj_hap_func_t func,
                         typed_lang_void *user_data);
</pre><pre class="jdocu_small" style="color: black">hap_handle_t
SIM_hap_add_callback_obj_index(const char *hap,
                               conf_object_t *obj,
                               hap_flags_t flags,
                               obj_hap_func_t func,
                               typed_lang_void *user_data,
                               integer_t index);
</pre><pre class="jdocu_small" style="color: black">hap_handle_t
SIM_hap_add_callback_obj_range(const char *hap,
                               conf_object_t *obj,
                               hap_flags_t flags,
                               obj_hap_func_t func,
                               typed_lang_void *user_data,
                               integer_t start,
                               integer_t end);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Registers a function, pointed to by <i>func</i>, to be called
   when <i>hap</i> occurs for object <i>obj</i>.
   If <i>obj</i> is NULL (None in Python), or a hap add function that
   does not have the <i>obj</i> argument is used, then the callback
   function will be called regardless of what object that triggers
   the hap. The <i>user_data</i> argument is the callback-specific
   data, and it will be passed as first argument to the installed callback
   function.
<p>
   Some hap add functions also take a <i>flags</i> argument. This flag
   is currently Simics internal and should be set to 0.
<p>
   The hap callback functions should not return any data. In C, the functions
   are declared to have a <tt>void</tt> return type and in Python, any
   return value is ignored. Since callback functions with different arguments
   may be installed using the same API function, the compiler may warn about a
   type mismatch. The solution is to cast the callback function pointer to the
   <tt>obj_hap_func_t</tt> type.
<p>
   In hap functions, the execution can be interrupted by calling
   <b><i>SIM_break_simulation</i></b>. If a frontend or Python exception is
   raised, an error message will be printed incuding a stack trace if the
   callback is written in Python.
<p>
   The <tt>_index_</tt> and <tt>_range_</tt> versions will install callbacks
   that only trigger for a specified index, or range of indices. The index
   is specific for each hap type, see the hap documentation.
<p>
   <a name="label501"></a>
<pre class="jdocu_small" style="color: black">typedef int hap_handle_t;</pre>
</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>

   The return value is a hap callback handle (identifier) of the type
   <tt>hap_handle_t</tt>. This handle can be used to remove the installed
   callback with <b><i>SIM_hap_delete_callback_id</i></b>.
   </dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>

   <b>Lookup</b> Thrown if the hap does not exist.<br>
   <b>Attribute</b> Thrown if the callback is not valid.
   </dd>
</dl>
<a name="label502"></a><h6 class="jdocu">SIM_hap_add_type()</h6 class="jdocu">

<a name="label503"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label504"></a><b>SIM_hap_add_type</b> &#8212; register a new hap type</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">hap_type_t
SIM_hap_add_type(const char *hap,
                 const char *params,
                 const char *param_desc,
                 const char *index,
                 const char *desc,
                 int old_had_obj);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Creates a run-time defined hap type. 
<p>
   The <i>params</i> parameter specifies the argument that callbacks
   for this hap is called with, e.g., <tt>"s"</tt> or
   <tt>"II"</tt>. The first two arguments are always <tt>lang_void *</tt>
   and <tt>conf_object_t *</tt> respectively, and should not be included
   in that string. The table below shows which characters may be used, and
   what their meaning is:
<p>
   <table>
<tr><td class="jdocu_noborder"><tt>i</tt></td><td class="jdocu_noborder">an int</td></tr>
<tr><td class="jdocu_noborder"><tt>I</tt></td><td class="jdocu_noborder">an integer_t (64 bit integer)</td></tr>
<tr><td class="jdocu_noborder"><tt>e</tt></td><td class="jdocu_noborder">an <tt>exception_type_t</tt></td></tr>
<tr><td class="jdocu_noborder"><tt>o</tt></td><td class="jdocu_noborder">a script specific object; i.e.,
           <tt>void *</tt> in C and any Python object in Python</td></tr>
<tr><td class="jdocu_noborder"><tt>s</tt></td><td class="jdocu_noborder">a string</td></tr>
<tr><td class="jdocu_noborder"><tt>m</tt></td><td class="jdocu_noborder">a memory transaction
           (<tt>generic_transaction_t *</tt> in C)</td></tr>
<tr><td class="jdocu_noborder"><tt>c</tt></td><td class="jdocu_noborder">a configuration object
           (<tt>conf_object_t *</tt> in C)</td></tr>
<tr><td class="jdocu_noborder"><tt>v</tt></td><td class="jdocu_noborder">a <tt>void *</tt>; a pointer to a C structure
           within Simics</td></tr>
</table>
<p>
   <i>parm_desc</i> should be a string of space-separated words
   describing these parameters, or NULL if <i>params</i> is the empty
   string.
<p>
   <i>index</i> is a string describing the index value for this hap, or
   NULL if there is no index value.
<p>
   Hap types that used to have a conf_object_t pointer as first argument
   (before all haps were associated with an object) should set the
   <i>old_had_obj</i> argument to 1. This tells Simics to call old-style
   callbacks with a conf_object_t argument although the hap doesn't include any
   'c' first in the parameter list anymore. Old style callbacks are functions
   installed with the now obsolete <b><i>SIM_hap_register_callback...</i></b> and
   <b><i>SIM_hap_install_callback...</i></b> functions.
<p>
   <i>desc</i> is a description string for the hap.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>General</b> Thrown if hap is already defined.
   However, consequent calls with the same parameters will be successful, and
   return the same hap type number each time.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The hap type number or a number &lt;= 0 on
   error.</dd>
</dl>
<a name="label505"></a><h6 class="jdocu">SIM_hap_callback_exists()</h6 class="jdocu">

<a name="label506"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label507"></a><b>SIM_hap_callback_exists</b> &#8212; get callback status</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_hap_callback_exists(const char *hap,
                        obj_hap_func_t func,
                        typed_lang_void *user_data);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Checks if there is an installed callback <i>func</i>
   with associated <i>user_data</i> for hap <i>hap</i>.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>

   <b>Lookup</b> Thrown if no hap is associated with name <i>id</i>.
   </dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>

   1 if such a callback exists, 0 otherwise.
   </dd>
</dl>
<a name="label508"></a><h6 class="jdocu">SIM_hap_delete_callback()</h6 class="jdocu">

<a name="label509"></a><a name="label510"></a><a name="label511"></a><a name="label512"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label513"></a><b>SIM_hap_delete_callback</b><b>, SIM_hap_delete_callback_obj</b><b>, SIM_hap_delete_callback_id</b><b>, SIM_hap_delete_callback_obj_id</b> &#8212; delete installed hap callback</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_hap_delete_callback(const char *hap,
                        obj_hap_func_t func, typed_lang_void *user_data);
</pre><pre class="jdocu_small" style="color: black">void
SIM_hap_delete_callback_obj(const char *hap,
                            conf_object_t *obj,
                            obj_hap_func_t func, typed_lang_void *user_data);
</pre><pre class="jdocu_small" style="color: black">void
SIM_hap_delete_callback_id(const char *hap, hap_handle_t handle);
</pre><pre class="jdocu_small" style="color: black">void
SIM_hap_delete_callback_obj_id(const char *hap,
                               conf_object_t *obj, hap_handle_t handle);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Removes a callback for a hap type specified by the <tt>hap</tt> argument.
<p>
   The <b><i>SIM_hap_delete_callback_obj...()</i></b> functions will remove a
   callback that is installed on the specified object <i>obj</i>.
<p>
   <b><i>SIM_hap_delete_callback()</i></b> removes any callbacks with the
   callback function <tt>func</tt> and the same <tt>user_data</tt>. The
   <b><i>SIM_hap_delete_callback_..._id()</i></b> functions take a hap handle
   argument instead, as returned by the <b><i>SIM_hap_add_callback...()</i></b>
   functions.
<p>
   These function will trigger the <tt>Core_Hap_Callback_Removed</tt> hap
   for each removed callback. <i>NOTE:</i> Callbacks registered to be
   called on <tt>Core_Hap_Callback_Removed</tt>, are not allowed to make
   recursive calls to remove or unregister any callbacks on the same hap.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>

   <b>Lookup</b> Thrown if the specified hap does not exist.
   </dd>
</dl>
<a name="label514"></a><h6 class="jdocu">SIM_hap_get_name()</h6 class="jdocu">

<a name="label515"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label516"></a><b>SIM_hap_get_name</b> &#8212; get hap name by number</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">const char *
SIM_hap_get_name(hap_type_t hap);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the name of <i>hap</i>, or <tt>NULL</tt> for no
   such hap.</dd>

<p>
</dl>
<a name="label517"></a><h6 class="jdocu">SIM_hap_get_number()</h6 class="jdocu">

<a name="label518"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label519"></a><b>SIM_hap_get_number</b> &#8212; get hap number by name</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">hap_type_t
SIM_hap_get_number(const char *hap);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the runtime number associated with a hap identifier.
   All haps are listed in section <a class="jdocu" href="topic544.html#label18015">8</a>.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>

   <b>Lookup</b> Thrown if no hap is associated with name <i>id</i>.
   </dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>

   The hap type number, or 0 on failure.
   </dd>
</dl>
<a name="label520"></a><h6 class="jdocu">SIM_hap_is_active()</h6 class="jdocu">

<a name="label521"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label522"></a><b>SIM_hap_is_active</b> &#8212; check if hap has callbacks</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_hap_is_active(hap_type_t hap);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns 1 if the hap has any callback functions installed,
   and 0 if not.</dd>

<p>
</dl>
<a name="label523"></a><h6 class="jdocu">SIM_hap_occurred()</h6 class="jdocu">

<a name="label524"></a><a name="label525"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label526"></a><b>SIM_hap_occurred</b><b>, SIM_hap_occurred_always</b> &#8212; trigger hap occurrence</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_hap_occurred(hap_type_t hap, conf_object_t *obj,
                 integer_t value, attr_value_t *list);
</pre><pre class="jdocu_small" style="color: black">int
SIM_hap_occurred_always(hap_type_t hap, conf_object_t *obj,
                        integer_t value, attr_value_t *list);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Used to notify that a particular hap has occurred. All callbacks
   installed for the hap will be called. The value is used to check
   range. The hap specific data is passed as the first parameter to
   the callback function (see <b><i>SIM_hap_add_callback()</i></b>)
   A positive return indicates the number of callback that was
   installed and run.
<p>
   SIM_hap_occurred() will only call the callbacks once in a simulated
   cycle; i.e., it is safe to call SIM_hap_occurred() and request the
   simulation to stop every time. The SIM_hap_occurred_always()
   function will always call the hap functions every time.</dd>

<p>
<dt class="jdocu_descitem">NOTES</dt><dd>

     There are also versions of these functions
     that only can be called from C (with var-args), SIM_c_hap_occurred(), 
     and SIM_c_hap_occurred_always().
   </dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>

     An exception is thrown upon errors or
     if a callback requested the simulation to stop. The kind of
     exception depends on the callback.
   </dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>

     The number of callbacks installed on the hap.
   </dd>
</dl>
<a name="label527"></a><h6 class="jdocu">SIM_hap_remove_type()</h6 class="jdocu">

<a name="label528"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label529"></a><b>SIM_hap_remove_type</b> &#8212; remove a hap type</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_hap_remove_type(const char *hap);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Remove a run-time defined hap type.</dd>

<p>
</dl>

<a name="label530"></a><h5 class="jdocu">Logging</h5 class="jdocu">
<a name="label531"></a><h6 class="jdocu">SIM_get_quiet()</h6 class="jdocu">

<a name="label532"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label533"></a><b>SIM_get_quiet</b> &#8212; return setting of the quiet flag</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_get_quiet(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function returns the current value of Simics's quiet flag.</dd>

<p>
</dl>
<a name="label534"></a><h6 class="jdocu">SIM_get_verbose()</h6 class="jdocu">

<a name="label535"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label536"></a><b>SIM_get_verbose</b> &#8212; get the verbose flag</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_get_verbose(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function returns the value of Simics's verbosity flag
   (corresponding to the <tt>-verbose</tt> command-line argument).</dd>

<p>
</dl>
<a name="label537"></a><h6 class="jdocu">SIM_log_constructor()</h6 class="jdocu">

<a name="label538"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label539"></a><b>SIM_log_constructor</b> &#8212; initiate log class</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_log_constructor(log_object_t *log_obj, parse_object_t *parse_obj);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This constructor should be called by new_instance functions
   to initialize a new log object.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="topic7.html#label128">log_object_t</a>, <a class="jdocu" href="#label550"> SIM_log_message</a>, <a class="jdocu" href="#label553"> 
   SIM_log_register_groups</a></dl>
<a name="label540"></a><h6 class="jdocu">SIM_log_info()</h6 class="jdocu">

<a name="label541"></a><a name="label542"></a><a name="label543"></a><a name="label544"></a><a name="label545"></a><a name="label546"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label547"></a><b>SIM_log_info</b><b>, SIM_log_error</b><b>, SIM_log_undefined</b><b>, SIM_log_spec_violation</b><b>, SIM_log_target_error</b><b>, SIM_log_unimplemented</b> &#8212; output log message</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">static void
SIM_log_info(int lvl, log_object_t *dev, int grp,
             const char *str, ...);
</pre><pre class="jdocu_small" style="color: black">static void
SIM_log_error(log_object_t *dev, int grp,
              const char *str, ...);
</pre><pre class="jdocu_small" style="color: black">static void
SIM_log_undefined(int lvl, log_object_t *dev, int grp,
                  const char *str, ...);
</pre><pre class="jdocu_small" style="color: black">static void
SIM_log_spec_violation(int lvl, log_object_t *dev, int grp,
                       const char *str, ...);
</pre><pre class="jdocu_small" style="color: black">static void
SIM_log_target_error(int lvl, log_object_t *dev, int grp,
                     const char *str, ...);
</pre><pre class="jdocu_small" style="color: black">static void
SIM_log_unimplemented(int lvl, log_object_t *dev, int grp,
                      const char *str, ...);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_log_info()</i></b> etc are C macros that should be used by devices
   and extensions which are based on a <tt>log_object_t</tt> to print 
   information and error messages. For more information, see the
   <b><i>SIM_log_message</i></b> function. Each macros represents a log type.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label550">SIM_log_message</a>, <a class="jdocu" href="#label539"> SIM_log_constructor</a></dl>
<a name="label548"></a><h6 class="jdocu">SIM_log_message()</h6 class="jdocu">

<a name="label549"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label550"></a><b>SIM_log_message</b> &#8212; print and log message</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_log_message(conf_object_t *obj,
                int level,
                int group_ids,
                log_type_t log_type,
                const char *message);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Prints and logs a message associated with a <tt>log_object_t</tt> object.
   Objects written in C/C++ should use the <b><i>SIM_log_&lt;log-type&gt;()</i></b>
   macros instead.
<p>
   <i>level</i> should be between 1 and 4:
   <ol>
     <li>important messages printed by default</li>
     <li>"high-level" informative messages</li>
     <li>standard debug messages</li>
     <li>detailed information, such as register accesses</li>
   </ol>
<p>
   Messages of the <tt>Sim_Log_Error</tt> type are always printed on
   level 1. The <i>group_ids</i> should have a bit set for each log group
   that the message corresponds to, as defined by the
   <b><i>SIM_log_register_groups()</i></b>.  The <i>log_type</i> argument is
   documented with the <tt>log_type_t</tt> type.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label539">SIM_log_constructor</a>, <a class="jdocu" href="#label553"> SIM_log_register_groups</a>, <a class="jdocu" href="topic7.html#label130"> 
     log_type_t</a></dl>
<a name="label551"></a><h6 class="jdocu">SIM_log_register_groups()</h6 class="jdocu">

<a name="label552"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label553"></a><b>SIM_log_register_groups</b> &#8212; register names of log groups</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_log_register_groups(conf_class_t *cls, const char **names);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Register a list of log groups that a <tt>log_object_t</tt> object can
   use to separate messages. The order of the groups in the list defines the
   group ids that should be used in the call to
   <b><i>SIM_log_message()</i></b>. The <i>group_ids</i> argument to that
   function should have a bit set corresponding to the group; i.e., a value of
   1 for the first group, 2 for the second, 4 for the third,
   etc. <i>names</i> should be a <tt>NULL</tt>-terminated array.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label539">SIM_log_constructor</a>, <a class="jdocu" href="#label553"> SIM_log_register_groups</a></dl>
<a name="label554"></a><h6 class="jdocu">SIM_set_quiet()</h6 class="jdocu">

<a name="label555"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label556"></a><b>SIM_set_quiet</b> &#8212; enable/disable quiet mode</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_set_quiet(int mode);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Calling this function with an argument of 1 will enable the quiet mode,
   whereas an argument of 0 will disable it. Any other arguments will cause
   a frontend exception. Please note that enabling the quiet mode will
   disable verbose mode.</dd>

<p>
</dl>
<a name="label557"></a><h6 class="jdocu">SIM_set_verbose()</h6 class="jdocu">

<a name="label558"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label559"></a><b>SIM_set_verbose</b> &#8212; set the verbose flag</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_set_verbose(int mode);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function sets Simics's internal verbosity flag (corresponding to the
   <tt>-verbose</tt> command-line argument). The <tt>mode</tt> argument can
   be either 0 or 1. Note that setting this flag will disable quiet mode.</dd>

<p>
</dl>

<a name="label560"></a><h5 class="jdocu">Memory</h5 class="jdocu">
<a name="label561"></a><h6 class="jdocu">SIM_for_all_memory_pages()</h6 class="jdocu">

<a name="label562"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label563"></a><b>SIM_for_all_memory_pages</b> &#8212; apply callback function to all memory pages</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_for_all_memory_pages(void (*func)(integer_t addr), int i_or_d);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Iterate through all known pages of memory and call a function for
   every page.
<p>
   The callback <i>func</i> is passed the physical address of the
   first byte on the page. Each page is S_PSIZE bytes large.
<p>
   If i_or_d is 0, then <i>func</i> is only applied to pages that
   have had code executed on them (i.e. intermediate code has been
   allocated at some time).</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>General</b> Thrown if <i>func</i> is NULL.</dd>
<dt class="jdocu_descitem">NOTE</dt><dd>
The memory pages are internal Simics pages. The
   size of a page may be different than the logical page size of the target
   architecture.</dd>
</dl>
<a name="label564"></a><h6 class="jdocu">SIM_load_binary()</h6 class="jdocu">

<a name="label565"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label566"></a><b>SIM_load_binary</b> &#8212; read an executable file into memory</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">physical_address_t
SIM_load_binary(conf_object_t *obj, const char *file,
                physical_address_t offset, int use_pa, int verbose);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Read a binary file (ELF, PE32, or PE32+ format) into memory and
   return the code entry point.
<p>
   The file will be loaded at the address formed by adding
   the virtual load address from the file, with the offset
   <i>offset</i>. If the flag <i>use_pa</i> is set, the ELF
   physical load address is used instead. The <i>verbose</i> flag
   will cause Simics to print info about the binary to the console.
<p>
   The memory space to load into is given in the <i>obj</i>
   parameter.  If the given space is a CPU object, its current virtual
   address space will be used, and addresses will be translated before
   writing to the physical memory space attached to the CPU.
<p>
   If the file is not found in the current directory, the search path (see
   <b>add-directory</b>) is used to find the file.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<tt>IOError</tt> Thrown if there
   was a problem reading the file.<br> <tt>Memory</tt> Thrown
   if binary cannot be read into memory.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The code entry address.</dd>
</dl>
<a name="label567"></a><h6 class="jdocu">SIM_load_file()</h6 class="jdocu">

<a name="label568"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label569"></a><b>SIM_load_file</b> &#8212; read a file into memory</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_load_file(conf_object_t *obj, const char *file,
              physical_address_t base_address, int verbose);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Reads a file straight into memory starting at physical address
   'base_address'. The flag 'verbose' will cause Simics to print
   info about the file to the console.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>Attribute</b> Thrown if no file is specified.<br>
   <b>IOError</b> Thrown if there was a problem reading the file.<br>
   <b>Memory</b> Thrown if file cannot be read into memory.</dd>
</dl>
<a name="label570"></a><h6 class="jdocu">SIM_logical_to_physical()</h6 class="jdocu">

<a name="label571"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label572"></a><b>SIM_logical_to_physical</b> &#8212; translate logical to physical</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">physical_address_t
SIM_logical_to_physical(conf_object_t *cpu,
                        data_or_instr_t data_or_instr, 
                        logical_address_t vaddr);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Translates logical to physical address, assumes a 'word read'
   operation in supervisor mode to the address using supplied processor.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>Memory</b> Thrown if no translation exists.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The physical address.</dd>
</dl>
<a name="label573"></a><h6 class="jdocu">SIM_read_byte()</h6 class="jdocu">

<a name="label574"></a><a name="label575"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label576"></a><b>SIM_read_byte</b><b>, SIM_write_byte</b> &#8212; read/write byte from a memory space</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">uint8
SIM_read_byte(conf_object_t *obj, generic_address_t paddr);
</pre><pre class="jdocu_small" style="color: black">void
SIM_write_byte(conf_object_t *obj, generic_address_t paddr, uint8 value);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Read or write a byte from a given address in the memory space <i>obj</i>.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>Memory</b> Thrown if the memory
   space threw an exception<br>
   <b>General</b> Thrown if the object does not implement the memory
   space interface, or if <i>obj</i> is
   <tt>NULL</tt>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The byte read.</dd>
</dl>
<a name="label577"></a><h6 class="jdocu">SIM_read_phys_memory()</h6 class="jdocu">

<a name="label578"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label579"></a><b>SIM_read_phys_memory</b> &#8212; read data from a physical address</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">uinteger_t
SIM_read_phys_memory(conf_object_t *cpu,
                     physical_address_t paddr,
                     int length);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Reads <i>length</i> bytes from address <i>paddr</i> in the physical
   memory space associated with the processor <i>cpu</i>.
<p>
   Up to 8 bytes can be read in one call. The memory access will be of
   inquiry type, i.e. no timing-model or snoop device will be called.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>Memory</b> Thrown if no memory defined at
   <i>paddr</i>.<br>
   <b>Attribute</b> Thrown if <i>length</i> is out of range.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The read data, zero-extended.</dd>
</dl>
<a name="label580"></a><h6 class="jdocu">SIM_read_phys_memory_tags()</h6 class="jdocu">

<a name="label581"></a><a name="label582"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label583"></a><b>SIM_read_phys_memory_tags</b><b>, SIM_write_phys_memory_tags</b> &#8212; access auxiliary bits in physical memory</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">uint64
SIM_read_phys_memory_tags(conf_object_t *mem_space, physical_address_t paddr,
                          unsigned ntags);
</pre><pre class="jdocu_small" style="color: black">void
SIM_write_phys_memory_tags(conf_object_t *mem_space, physical_address_t paddr,
                           uint64 tag_bits, unsigned ntags);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Reads or writes <i>ntags</i> auxiliary bits starting at <i>paddr</i>
   in the physical memory space <i>mem_space</i>.
   Up to 64 bits can be accessed at once. The bits are specified and returned
   right-aligned, least significant bit corresponding to the lowest address.</dd>

<p>
</dl>
<a name="label584"></a><h6 class="jdocu">SIM_write_phys_memory()</h6 class="jdocu">

<a name="label585"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label586"></a><b>SIM_write_phys_memory</b> &#8212; write data to a physical address</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_write_phys_memory(conf_object_t *cpu,
                      physical_address_t paddr,
                      uinteger_t value, int length);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Writes <i>length</i> bytes to address <i>paddr</i> in the physical
   memory space associated with the processor <i>cpu</i>.
<p>
   Up to 8 bytes can be written in one call. The memory access will be of
   inquiry type, i.e. no timing-model or snoop device will be called.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>Memory</b> Thrown if no memory defined at
   <i>paddr</i>.<br>
   <b>Attribute</b> Thrown if <i>length</i> is out of range.</dd>
</dl>

<a name="label587"></a><h5 class="jdocu">Memory Transactions</h5 class="jdocu">
<a name="label588"></a><h6 class="jdocu">SIM_alpha_mem_trans_from_generic()</h6 class="jdocu">

<a name="label589"></a><a name="label590"></a><a name="label591"></a><a name="label592"></a><a name="label593"></a><a name="label594"></a><a name="label595"></a><a name="label596"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label597"></a><b>SIM_alpha_mem_trans_from_generic</b><b>, SIM_arm_mem_trans_from_generic</b><b>, SIM_ia64_mem_trans_from_generic</b><b>, SIM_mips_mem_trans_from_generic</b><b>, SIM_ppc_mem_trans_from_generic</b><b>, SIM_v9_mem_trans_from_generic</b><b>, SIM_x86_mem_trans_from_generic</b><b>, SIM_pci_mem_trans_from_generic</b> &#8212; convert generic transaction to CPU specific</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">struct alpha_memory_transaction *
SIM_alpha_mem_trans_from_generic(generic_transaction_t *mop);
</pre><pre class="jdocu_small" style="color: black">struct arm_memory_transaction *
SIM_arm_mem_trans_from_generic(generic_transaction_t *mop);
</pre><pre class="jdocu_small" style="color: black">struct ia64_memory_transaction *
SIM_ia64_mem_trans_from_generic(generic_transaction_t *mop);
</pre><pre class="jdocu_small" style="color: black">struct mips_memory_transaction *
SIM_mips_mem_trans_from_generic(generic_transaction_t *mop);
</pre><pre class="jdocu_small" style="color: black">struct ppc_memory_transaction *
SIM_ppc_mem_trans_from_generic(generic_transaction_t *mop);
</pre><pre class="jdocu_small" style="color: black">struct v9_memory_transaction *
SIM_v9_mem_trans_from_generic(generic_transaction_t *mop);
</pre><pre class="jdocu_small" style="color: black">struct x86_memory_transaction *
SIM_x86_mem_trans_from_generic(generic_transaction_t *mop);
</pre><pre class="jdocu_small" style="color: black">struct pci_memory_transaction *
SIM_pci_mem_trans_from_generic(generic_transaction_t *mop);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Converts a pointer to a generic memory transaction into a pointer
   to a CPU specific memory transaction. The generic memory transaction
   must be part of a CPU specific one for this function to succeed.
   The pointer returned will be the same the input pointer if conversion
   is allowed, and NULL on failure.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>Type</b> Thrown if the generic transaction is
   not part of a CPU specific transaction.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
New memory transaction pointer, or NULL on error.</dd>
</dl>
<a name="label598"></a><h6 class="jdocu">SIM_c_get_mem_op_value_buf()</h6 class="jdocu">

<a name="label599"></a><a name="label600"></a><a name="label601"></a><a name="label602"></a><a name="label603"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label604"></a><b>SIM_c_get_mem_op_value_buf</b><b>, SIM_get_mem_op_value_buf</b><b>, SIM_get_mem_op_value_cpu</b><b>, SIM_get_mem_op_value_le</b><b>, SIM_get_mem_op_value_be</b> &#8212; get value for a memory operation</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_c_get_mem_op_value_buf(generic_transaction_t *mop, char *dst);
</pre><pre class="jdocu_small" style="color: black">attr_value_t
SIM_get_mem_op_value_buf(generic_transaction_t *mop);
</pre><pre class="jdocu_small" style="color: black">uinteger_t
SIM_get_mem_op_value_cpu(generic_transaction_t *mop);
</pre><pre class="jdocu_small" style="color: black">uinteger_t
SIM_get_mem_op_value_le(generic_transaction_t *mop);
</pre><pre class="jdocu_small" style="color: black">uinteger_t
SIM_get_mem_op_value_be(generic_transaction_t *mop);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns load or store value for a memory transaction. If the data
   size is 8 bytes or less the <b><i>SIM_get_mem_op_value_be()</i></b> 
   and <b><i>SIM_get_mem_op_value_le()</i></b> functions can be used. For
   reads/writes larger than 8 bytes, the functions
   <b><i>SIM_c_get_mem_op_value_buf()</i></b> or <b><i>SIM_get_mem_op_value_buf()</i></b>
   should be used to get the data.
<p>
   The <b><i>SIM_c_get_mem_op_value_buf()</i></b> function is only available
   from C/C++. It places the data into the buffer pointed to by <i>dst</i>.
   No endian conversion is performed, i.e. data is returned in target
   endianness. There is no alignment requirement on the <tt>dst</tt>
   parameter.</dd>

<p>
<dt class="jdocu_descitem">WARNING</dt><dd>
 When called from a memory-hierarchy
   (timing-model) only store values can be retrieved, since the load
   has not yet performed. To get the load value, a <i>snoop-device</i>
   should be used.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>

   <b><i>SIM_c_get_mem_op_value_buf()</i></b> returns nothing. The out
   parameter <i>dst</i> is filled with the data buffer of the memory
   transaction. <b><i>SIM_get_mem_op_value_buf()</i></b> returns an
   <tt>attr_value_t</tt> containing the the data buffer (type
   <tt>Sim_Val_Data</tt>) of the memory transaction.
   <b><i>SIM_get_mem_op_value_be()</i></b> returns the zero-extended value
   in host endian order (interpreted as big endian) for the memory transaction.
   <b><i>SIM_get_mem_op_value_le()</i></b> returns the zero-extended value
   in host endian order (interpreted as little endian).
   <b><i>SIM_get_mem_op_value_cpu()</i></b> interprets the data in the
   default endian order for the initiating processor.
   </dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>Memory</b> Thrown if the size of the
   operation is illegal.</dd>
</dl>
<a name="label605"></a><h6 class="jdocu">SIM_c_set_mem_op_value_buf()</h6 class="jdocu">

<a name="label606"></a><a name="label607"></a><a name="label608"></a><a name="label609"></a><a name="label610"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label611"></a><b>SIM_c_set_mem_op_value_buf</b><b>, SIM_set_mem_op_value_buf</b><b>, SIM_set_mem_op_value_cpu</b><b>, SIM_set_mem_op_value_le</b><b>, SIM_set_mem_op_value_be</b> &#8212; set value for a memory operation</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_c_set_mem_op_value_buf(generic_transaction_t *mop, char *src);
</pre><pre class="jdocu_small" style="color: black">void
SIM_set_mem_op_value_buf(generic_transaction_t *mop, attr_value_t value);
</pre><pre class="jdocu_small" style="color: black">void
SIM_set_mem_op_value_cpu(generic_transaction_t *mop, uinteger_t value);
</pre><pre class="jdocu_small" style="color: black">void
SIM_set_mem_op_value_le(generic_transaction_t *mop, uinteger_t value);
</pre><pre class="jdocu_small" style="color: black">void
SIM_set_mem_op_value_be(generic_transaction_t *mop, uinteger_t value);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Set the value returned to the requester of a memory operation.
   If the data size is 8 bytes or less the <b><i>SIM_set_mem_op_value_be()</i></b>
   and <b><i>SIM_set_mem_op_value_le</i></b> functions can be used. For sizes
   larger than 8 bytes, the functions <b><i>SIM_c_set_mem_op_value_buf()</i></b>
   or <b><i>SIM_set_mem_op_value_buf()</i></b> should be used to set the data.
<p>
   <b><i>SIM_c_set_mem_op_value_buf()</i></b> is only available from C/C++,
   it operates on data in target endian order. There is no alignment
   requirement on the <tt>buf</tt> parameter.
<p>
   <b><i>SIM_set_mem_op_value_be()</i></b> takes data in host endian order
   and sets it in big-endian.
<p>
   <b><i>SIM_set_mem_op_value_le()</i></b> takes data in host endian order
   and sets it in little-endian.
<p>
   <b><i>SIM_set_mem_op_value_cpu()</i></b> takes data in host endian order
   and sets it in the default endian order for the initiating processor.</dd>

<p>
<dt class="jdocu_descitem">WARNING</dt><dd>
These functions cannot be called from a
   <i>timing-model</i> since the real operation will overwrite the value
   set. They should instead be used from a <i>snoop-device</i>.
   </dd>
</dl>
<a name="label612"></a><h6 class="jdocu">SIM_get_mem_op_type()</h6 class="jdocu">

<a name="label613"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label614"></a><b>SIM_get_mem_op_type</b> &#8212; get type of transaction</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">FORCE_INLINE mem_op_type_t
SIM_get_mem_op_type(const generic_transaction_t *NOTNULL mop);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function returns the type of the memory transaction.</dd>

<p>
</dl>
<a name="label615"></a><h6 class="jdocu">SIM_get_mem_op_type_name()</h6 class="jdocu">

<a name="label616"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label617"></a><b>SIM_get_mem_op_type_name</b> &#8212; get name of memory operation type</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">const char *
SIM_get_mem_op_type_name(mem_op_type_t type);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns a string describing <i>type</i> or <tt>NULL</tt>
   if unknown.</dd>

<p>
</dl>
<a name="label618"></a><h6 class="jdocu">SIM_get_unique_memory_transaction_id()</h6 class="jdocu">

<a name="label619"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label620"></a><b>SIM_get_unique_memory_transaction_id</b> &#8212; get unique memory transaction ID</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_get_unique_memory_transaction_id(conf_object_t *obj);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns a number which is unique for all currently outstanding
   memory operations of the specified CPU <i>obj</i>. You can read
   the last value returned by this function by calling
   <b><i>SIM_get_current_memory_transaction_id()</i></b>.</dd>

<p>
</dl>
<a name="label621"></a><h6 class="jdocu">SIM_mem_op_is_control()</h6 class="jdocu">

<a name="label622"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label623"></a><b>SIM_mem_op_is_control</b> &#8212; transaction control predicates</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">FORCE_INLINE int
SIM_mem_op_is_control(const generic_transaction_t *NOTNULL mop);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Checks whether <tt>mem_op</tt> is control transaction.</dd>

<p>
</dl>
<a name="label624"></a><h6 class="jdocu">SIM_mem_op_is_data()</h6 class="jdocu">

<a name="label625"></a><a name="label626"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label627"></a><b>SIM_mem_op_is_data</b><b>, SIM_mem_op_is_instruction</b> &#8212; transaction data/instruction predicates</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">FORCE_INLINE int
SIM_mem_op_is_data(const generic_transaction_t *NOTNULL mop);
</pre><pre class="jdocu_small" style="color: black">FORCE_INLINE int
SIM_mem_op_is_instruction(const generic_transaction_t *NOTNULL mop);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions check whether <tt>mem_op</tt> is a data or an instruction
  transaction. Currently, the only transactions that are instruction
  transactions are instruction fetches.</dd>

<p>
</dl>
<a name="label628"></a><h6 class="jdocu">SIM_mem_op_is_from_cache()</h6 class="jdocu">

<a name="label629"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label630"></a><b>SIM_mem_op_is_from_cache</b> &#8212; Cache initiated transaction</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">FORCE_INLINE int
SIM_mem_op_is_from_cache(const generic_transaction_t *NOTNULL mop);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Checks whether <tt>mem_op</tt> is sent from a cache timing model.</dd>

<p>
</dl>
<a name="label631"></a><h6 class="jdocu">SIM_mem_op_is_from_cpu()</h6 class="jdocu">

<a name="label632"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label633"></a><b>SIM_mem_op_is_from_cpu</b> &#8212; CPU initiated transaction</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">FORCE_INLINE int
SIM_mem_op_is_from_cpu(const generic_transaction_t *NOTNULL mop);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Checks whether <tt>mem_op</tt> is sent from a processor.</dd>

<p>
</dl>
<a name="label634"></a><h6 class="jdocu">SIM_mem_op_is_from_cpu_arch()</h6 class="jdocu">

<a name="label635"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label636"></a><b>SIM_mem_op_is_from_cpu_arch</b> &#8212; CPU initiated transaction</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">FORCE_INLINE int
SIM_mem_op_is_from_cpu_arch(const generic_transaction_t *NOTNULL mop,
                            ini_type_t arch);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Checks whether <tt>mem_op</tt> is sent from a processor
  of a specific architecture.</dd>

<p>
</dl>
<a name="label637"></a><h6 class="jdocu">SIM_mem_op_is_from_device()</h6 class="jdocu">

<a name="label638"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label639"></a><b>SIM_mem_op_is_from_device</b> &#8212; Device initiated transaction</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">FORCE_INLINE int
SIM_mem_op_is_from_device(const generic_transaction_t *NOTNULL mop);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Checks whether <tt>mem_op</tt> is sent from a device.</dd>

<p>
</dl>
<a name="label640"></a><h6 class="jdocu">SIM_mem_op_is_prefetch()</h6 class="jdocu">

<a name="label641"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label642"></a><b>SIM_mem_op_is_prefetch</b> &#8212; transaction control predicates</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">FORCE_INLINE int
SIM_mem_op_is_prefetch(const generic_transaction_t *NOTNULL mop);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Checks whether <tt>mem_op</tt> is prefetch transaction.</dd>

<p>
</dl>
<a name="label643"></a><h6 class="jdocu">SIM_mem_op_is_read()</h6 class="jdocu">

<a name="label644"></a><a name="label645"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label646"></a><b>SIM_mem_op_is_read</b><b>, SIM_mem_op_is_write</b> &#8212; transaction read/write predicates</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">FORCE_INLINE int
SIM_mem_op_is_read(const generic_transaction_t *NOTNULL mop);
</pre><pre class="jdocu_small" style="color: black">FORCE_INLINE int
SIM_mem_op_is_write(const generic_transaction_t *NOTNULL mop);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions check whether <tt>mem_op</tt> is a read or a write
  transaction.</dd>

<p>
</dl>
<a name="label647"></a><h6 class="jdocu">SIM_set_mem_op_type()</h6 class="jdocu">

<a name="label648"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label649"></a><b>SIM_set_mem_op_type</b> &#8212; set type of transaction</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">FORCE_INLINE void
SIM_set_mem_op_type(generic_transaction_t *NOTNULL mop, mem_op_type_t type);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
</dd>

<p>
</dl>

<a name="label650"></a><h5 class="jdocu">Modules</h5 class="jdocu">
<a name="label651"></a><h6 class="jdocu">SIM_get_all_failed_modules()</h6 class="jdocu">

<a name="label652"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label653"></a><b>SIM_get_all_failed_modules</b> &#8212; return a list of all modules that failed to load</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">attr_value_t
SIM_get_all_failed_modules(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
A failed module is a module that is not loadable by the current version
   of Simics. The list returned contains information about why the module
   failed. Each list entry is another list with module specific information.
   The layout of this sub-list is described below. The list may grow in future
   Simics version, but the currently defined fields will not change.
   <ul>
   <li><i>name</i> - Module name (Sim_Val_String).</li>
   <li><i>path</i> - File system path to the module (Sim_Val_String).</li>
   <li><i>duplicate</i> - Flag indicating a duplicate module
   (Sim_Val_Boolean).</li>
   <li><i>linker</i> - Flag indicating a linker error. (Sim_Val_Boolean).</li>
   <li><i>version</i> - Simics ABI version that the module is build for
   (Sim_Val_Integer).</li>
   <li><i>user version</i> - User version of the module (Sim_Val_String).</li>
   <li><i>error</i> - Error message, typically from the linker
   (Sim_Val_String or Sim_Val_Nil).</li>
   </ul></dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label656">SIM_get_all_modules</a></dl>
<a name="label654"></a><h6 class="jdocu">SIM_get_all_modules()</h6 class="jdocu">

<a name="label655"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label656"></a><b>SIM_get_all_modules</b> &#8212; return a list of all modules</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">attr_value_t
SIM_get_all_modules(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The list returned contains information about all modules that can be loaded
   into Simics. Each list entry is another list with module specific
   information. The layout of this sub-list is described below. The list may
   grow in future Simics version, but the currently defined fields will not
   change.
   <ul>
   <li><i>name</i> - Module name (Sim_Val_String).</li>
   <li><i>path</i> - File system path to the module (Sim_Val_String).</li>
   <li><i>loaded</i> - Flag indicating that the module is already loaded
   (Sim_Val_Boolean).</li>
   <li><i>version</i> - Simics ABI version that the module is build for
   (Sim_Val_Integer).</li>
   <li><i>user version</i> - User version of the module (Sim_Val_String).</li>
   </ul></dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label653">SIM_get_all_failed_modules</a></dl>
<a name="label657"></a><h6 class="jdocu">SIM_load_module()</h6 class="jdocu">

<a name="label658"></a><a name="label659"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label660"></a><b>SIM_load_module</b><b>, SIM_unload_module</b> &#8212; load/unload modules</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_load_module(const char *module);
</pre><pre class="jdocu_small" style="color: black">void
SIM_unload_module(const char *module);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Load a module (Simics extension). Simics supports dynamically
   loadable modules. Anything linked as dynamic can be loaded.
   SIM_load_module takes the module name <i>module</i> as argument
   and tries to link in the corresponding library file. Under Unix
   lib&lt;module&gt;.so will be used and under Windows &lt;module&gt;.dll.
   Python modules (.py) can also be loaded with this function.
   SIM_unload_module unloads a module if the module supports it.
<p>
   Modules should be placed in the simics lib directory or in a
   directory present in the SIMICS_EXTRA_LIB environment variable.</dd>

<p>
</dl>
<a name="label661"></a><h6 class="jdocu">SIM_module_list_refresh()</h6 class="jdocu">

<a name="label662"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label663"></a><b>SIM_module_list_refresh</b> &#8212; refresh list of loadable modules</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_module_list_refresh(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Simics maintains a list of all modules that can be loaded
   successfully. If a module is changed or added, the list has
   to be refreshed before Simics can load this module.</dd>

<p>
</dl>

<a name="label664"></a><h5 class="jdocu">Output</h5 class="jdocu">
<a name="label665"></a><h6 class="jdocu">SIM_add_output_handler()</h6 class="jdocu">

<a name="label666"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label667"></a><b>SIM_add_output_handler</b> &#8212; register output handler</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_add_output_handler(output_handler_t func, lang_void *user_data);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function registers <b><i>func(<i>user_data</i>,
   <i>buf</i>, <i>count</i>)</i></b> to be called whenever there
   is text output from Simics, where <i>data</i> is the pointer in
   the call to <b><i>SIM_remove_output_handler()</i></b>, <i>buf</i>
   is a pointer to the output data, and <i>count</i> is the number
   of bytes to be written.
<p>
   This is the definition of <tt>output_handler_t</tt>:
<p>
   <a name="label668"></a>
<pre class="jdocu_small" style="color: black">typedef void (*output_handler_t)(lang_void *data,
                                 const char *src, size_t length);</pre>
</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label671">SIM_remove_output_handler</a>, <a class="jdocu" href="#label679"> SIM_write</a></dl>
<a name="label669"></a><h6 class="jdocu">SIM_remove_output_handler()</h6 class="jdocu">

<a name="label670"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label671"></a><b>SIM_remove_output_handler</b> &#8212; unregister output handler</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_remove_output_handler(output_handler_t func, typed_lang_void *user_data);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function removes <i>func</i> as an output recipient. If
   <i>data</i> is <tt>NULL</tt>, all previously added output
   handlers (by a call to <b><i>SIM_add_output_handler()</i></b>) will be
   removed; otherwise, only those with equal <i>data</i> pointers will
   be removed.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label667">SIM_add_output_handler</a>, <a class="jdocu" href="#label679"> SIM_write</a></dl>
<a name="label672"></a><h6 class="jdocu">SIM_write()</h6 class="jdocu">

<a name="label673"></a><a name="label674"></a><a name="label675"></a><a name="label676"></a><a name="label677"></a><a name="label678"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label679"></a><b>SIM_write</b><b>, SIM_flush</b><b>, SIM_putchar</b><b>, SIM_puts</b><b>, SIM_printf</b><b>, SIM_printf_vararg</b> &#8212; text output routines</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_write(const void *src, int length);
</pre><pre class="jdocu_small" style="color: black">int
SIM_flush(void);
</pre><pre class="jdocu_small" style="color: black">int
SIM_putchar(int c);
</pre><pre class="jdocu_small" style="color: black">int
SIM_puts(const char *s);
</pre><pre class="jdocu_small" style="color: black">int
SIM_printf(const char *format, ...);
</pre><pre class="jdocu_small" style="color: black">int
SIM_printf_vararg(const char *format, va_list ap);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These are the Simics versions of the <b><i>write()</i></b>,
   <b><i>putchar()</i></b>, <b><i>puts()</i></b>, <b><i>printf()</i></b>,
   <b><i>vprintf()</i></b>, and <b><i>fflush()</i></b> C library functions.
   The arguments and return values
   are the same as for the library functions, except for
   <b><i>SIM_write()</i></b> which does not take any file argument.
<p>
   The output will be sent to <i>stdout</i>, but more output recipients
   can be added using the <b><i>SIM_add_output_handler()</i></b> function.
   Output is line buffered. <b><i>SIM_flush()</i></b> will force output of an
   unterminated line.
<p>
   By default, <tt>simics_api.h</tt> will define a number of macros,
   changing calls to the abovementioned C library functions to call the
   Simics versions instead:
<p>
   <span class="jdocu_smaller">
   
   <pre class="jdocu_small" style="color: black">#undef printf

#if defined(HAVE_VARARG_MACROS)
#define printf(...) SIM_printf(__VA_ARGS__)
#else
#define printf SIM_printf
#endif

#undef vprintf
#define vprintf(str, ap) SIM_printf_vararg(str, ap)

#undef puts
#define puts(str) SIM_puts(str)

#undef putchar
#define putchar(c) SIM_putchar(c)

#undef fwrite
#define fwrite(ptr, size, nmemb, stream)                \
        ((stream) == stdout                             \
         ? (size_t)SIM_write((ptr), (size) * (nmemb))   \
         : fwrite(ptr, size, nmemb, stream))

#undef fputs
#define fputs(str, stream)                      \
        ((stream) == stdout                     \
         ? SIM_write((str), strlen(str))        \
         : fputs((str), (stream)))

#undef fflush
#define fflush(stream) ((stream) == stdout ? SIM_flush() : fflush(stream))
</pre>
<p>
   <a name="label680"></a><a name="label681"></a><a name="label682"></a><a name="label683"></a>
   <a name="label684"></a><a name="label685"></a>
   
   </span>
<p>
   This behavior can be overridden, see the information about the
   <tt>SIM_BC_NO_STDOUT_REDEFINE</tt> macro in section <a class="jdocu" href="topic9.html#label1176">3.4.1</a>.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label667">SIM_add_output_handler</a></dl>

<a name="label686"></a><h5 class="jdocu">Path</h5 class="jdocu">
<a name="label687"></a><h6 class="jdocu">SIM_add_directory()</h6 class="jdocu">

<a name="label688"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label689"></a><b>SIM_add_directory</b> &#8212; add directory to search path</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_add_directory(const char *directory, int prepend);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Adds a directory to Simics's search-path. This is a list of directory
   which Simics uses when searching for files such as disk-dumps, kernel
   images, etc.
   <p>
   The <i>directory</i> argument is first converted using
   <b><i>SIM_native_path</i></b>, to yield a path on host native form.
   If the path does not exist, a warning is printed and the path is ignored.
<p>
   If <i>prepend</i> is set, the directory is inserted first in the
   list of directories.
<p>
   This list of directories is saved as the attribute
   <i>simics-path</i> when doing <b>write-configuration</b>.
   Each directory is first converted to absolute form if relative.
<p>
   This function replaces the obsolete function
   <b><i>SIM_set_simics_path()</i></b>.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label698">SIM_lookup_file</a></dl>
<a name="label690"></a><h6 class="jdocu">SIM_clear_directories()</h6 class="jdocu">

<a name="label691"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label692"></a><b>SIM_clear_directories</b> &#8212; clear the search path</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_clear_directories(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Deletes all directories from the search path.</dd>

<p>
</dl>
<a name="label693"></a><h6 class="jdocu">SIM_get_directories()</h6 class="jdocu">

<a name="label694"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label695"></a><b>SIM_get_directories</b> &#8212; get the current search path</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">attr_value_t
SIM_get_directories(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the current value of the directory search path.</dd>

<p>
</dl>
<a name="label696"></a><h6 class="jdocu">SIM_lookup_file()</h6 class="jdocu">

<a name="label697"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label698"></a><b>SIM_lookup_file</b> &#8212; find a file using simics-path</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">const char *
SIM_lookup_file(const char *file);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Searches for a file in the Simics search path as given to
   <b><i>SIM_add_directory()</i></b>. 
<p>
   The returned path will always be in host native format, so the
   returned path will not need to be converted. See
   <b><i>SIM_native_path</i></b> for more details on what "host native format"
   means.
<p>
   The search algorithm is as follows.
<p>
   <ul>
     <li> If <i>file</i> is <tt>NULL</tt>, the function fails. </li>
<p>
     <li> If <i>file</i> is an absolute path, it is converted
          to host native form and returned. If the file does not exist, the
          function fails.</li>
<p>
     <li> If <i>file</i> exists in or relative to the current
          directory, it is returned without using the directory list. This
          is more or less equivalent of always having "." first in the
          list.</li>
<p>
     <li> For each directory in the search path: The directory and the file
          is concatenated and converted to host native format. If the
          resulting file exists, it is returned.</li>
   </ul>
  <p>
   If the function fails, <tt>NULL</tt> is returned.
<p>
   If the file was found, a pointer to the full path to the file is
   returned. The returned string should not be modified.</dd>

<p>
</dl>
<a name="label699"></a><h6 class="jdocu">SIM_native_path()</h6 class="jdocu">

<a name="label700"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label701"></a><b>SIM_native_path</b> &#8212; convert path to its native form</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">char *
SIM_native_path(const char *NOTNULL path);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Translates a path to its host native form. The only platform for
   which this function is not a no-op is Windows. The translation can
   be disabled using the <tt>-no-use-cygpath</tt> command line flag.
<p>
   On Windows, this function translates Cygwin style paths into
   Windows native form. This is implemented internally, the
   <tt>cygpath</tt> utility is not invoked. If the path contains a
   colon (:) or a backslash, the path is assumed to be on native form
   already, and no translation will be performed.
<p>
   Translating a Cygwin paths is done by looking up Cygwin mount
   prefixes in the registry, and replacing any matching prefixes with
   their native counterpart. Also, Cygwin symlinks are resolved and
   followed. Finally, any slashes in the path is converted to
   backslash. The path is not normalized, i.e. the resulting path may
   contain "..".
<p>
   Note: the symlink lookup mechanism does not handle the case when
   <tt>nowinsymlink</tt> is set in the <tt>CYGWIN</tt>
   environment-variable.
<p>
   The function uses a static buffer to store its result, which will
   be overwritten at the next call.</dd>

<p>
</dl>

<a name="label702"></a><h5 class="jdocu">Processor</h5 class="jdocu">
<a name="label703"></a><h6 class="jdocu">SIM_current_processor()</h6 class="jdocu">

<a name="label704"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label705"></a><b>SIM_current_processor</b> &#8212; get current processor</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">conf_object_t *
SIM_current_processor(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns a pointer to the current processor. The returned processor pointer
   can be used in calls to other API functions, or as a reference to the
   processor in Python.<br>
   The current processor is the processor that Simics currently simulating. See
   the user manual for further explanation of Simics's simulation model.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>Lookup</b> Thrown if no processor exists.
   </dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Processor pointer.</dd>
</dl>
<a name="label706"></a><h6 class="jdocu">SIM_disassemble()</h6 class="jdocu">

<a name="label707"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label708"></a><b>SIM_disassemble</b> &#8212; disassemble instruction</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">tuple_int_string_t *
SIM_disassemble(conf_object_t *cpu, generic_address_t addr, int type);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function disassembles the instruction at the given
   address. Address is either a physical address (type == 0) or a
   logical address (type == 1).  A pointer to a
   <tt>tuple_int_string_t</tt> is returned which contains the
   disassembly string as well as the length of the instruction
   (bytes). <a name="label709">tuple_int_string_t</a> is defined like this:
   
   
<pre class="jdocu_small" style="color: black">typedef struct {
        int integer;
        const char *string;
} tuple_int_string_t;</pre>

   For the Sparc, Alpha, and PowerPC targets the length is always 4
   bytes.  On IA-64, the length is undefined.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>

   <b>General</b> Thrown if arguments are invalid.<br>
   <b>Memory</b> Thrown if the address is undefined or
   not mapped in the MMU (for logical addresses).</dd>
</dl>
<a name="label710"></a><h6 class="jdocu">SIM_enable_processor()</h6 class="jdocu">

<a name="label711"></a><a name="label712"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label713"></a><b>SIM_enable_processor</b><b>, SIM_disable_processor</b> &#8212; enable or disable a processor</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_enable_processor(conf_object_t *cpu);
</pre><pre class="jdocu_small" style="color: black">void
SIM_disable_processor(conf_object_t *cpu);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions disables (deactivates) or enables (reactivates) the
   specified processor. Processors that are disabled simply stall
   indefinitely. Make sure at least one processor is enabled at any given
   time. 
<p>
   This function can <em>not</em> be called during the execution of an
   instruction, for example, in a device or a timing-model. If you wish to call
   them in these situations, use <b><i>SIM_stacked_post()</i></b> to post a
   callback that will be run as soon as possible after the instruction
   finished.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>

   <b>General</b> Thrown if the processor already
   is enabled/disabled.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label744">SIM_processor_enabled</a></dl>
<a name="label714"></a><h6 class="jdocu">SIM_get_all_processors()</h6 class="jdocu">

<a name="label715"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label716"></a><b>SIM_get_all_processors</b> &#8212; get list of all processors</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">attr_value_t
SIM_get_all_processors(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return a list of all processor objects.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
List of processors.</dd>
</dl>
<a name="label717"></a><h6 class="jdocu">SIM_get_all_registers()</h6 class="jdocu">

<a name="label718"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label719"></a><b>SIM_get_all_registers</b> &#8212; get all register numbers</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">attr_value_t
SIM_get_all_registers(conf_object_t *cpu);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns a list of all register numbers for a processor. The register numbers
   can for example be used in calls to <b><i>SIM_read_register</i></b> and
   <b><i>SIM_write_register</i></b>.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
List of register numbers.</dd>
</dl>
<a name="label720"></a><h6 class="jdocu">SIM_get_exception_name()</h6 class="jdocu">

<a name="label721"></a><a name="label722"></a><a name="label723"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label724"></a><b>SIM_get_exception_name</b><b>, SIM_get_exception_number</b><b>, SIM_get_all_exceptions</b> &#8212; processor exception conversion utilities</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">const char *
SIM_get_exception_name(conf_object_t *cpu, int exc);
</pre><pre class="jdocu_small" style="color: black">int
SIM_get_exception_number(conf_object_t *cpu, const char *name);
</pre><pre class="jdocu_small" style="color: black">attr_value_t
SIM_get_all_exceptions(conf_object_t *cpu);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions convert from a processor exception number to the associated
   exception name and vice versa. The <b><i>SIM_get_all_exceptions</i></b>
   function can be used to get a list of all exceptions.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>

   <b>General</b> Thrown if exception cannot be found.<br>
   </dd>
</dl>
<a name="label725"></a><h6 class="jdocu">SIM_get_processor()</h6 class="jdocu">

<a name="label726"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label727"></a><b>SIM_get_processor</b> &#8212; get processor pointer from number</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">conf_object_t *
SIM_get_processor(int proc_no);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Converts processor id number to processor pointer. Note that processors are
   numbered from 0 to (number_processors - 1). This function cannot be used
   until a configuration had been loaded succcessfully.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>Index</b> Thrown if no processor with number
   <i>proc_no</i> exists.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The processor pointer, NULL on failure.</dd>
</dl>
<a name="label728"></a><h6 class="jdocu">SIM_get_processor_number()</h6 class="jdocu">

<a name="label729"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label730"></a><b>SIM_get_processor_number</b> &#8212; get the number of a processor</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_get_processor_number(const conf_object_t *cpu);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the global processor number for a processor in Simics.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The processor number</dd>
</dl>
<a name="label731"></a><h6 class="jdocu">SIM_get_program_counter()</h6 class="jdocu">

<a name="label732"></a><a name="label733"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label734"></a><b>SIM_get_program_counter</b><b>, SIM_set_program_counter</b> &#8212; read/write program counter</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">logical_address_t
SIM_get_program_counter(conf_object_t *cpu);
</pre><pre class="jdocu_small" style="color: black">void
SIM_set_program_counter(conf_object_t *cpu, logical_address_t pc);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions provide a portable way to examine and update the
   program counter and stack pointer of a processor.
<p>
   The actual registers that are read/written depend on the target
   architecture. For example on the x86-64 architecture the program
   counter is the RIP register and the stack pointer is the RSP
   register.
<p>
   For IA-64, the program counter is the <tt>ip</tt> register, with
   the current slot number added to the lowest two bits of the
   address.</dd>

<p>
</dl>
<a name="label735"></a><h6 class="jdocu">SIM_get_register_number()</h6 class="jdocu">

<a name="label736"></a><a name="label737"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label738"></a><b>SIM_get_register_number</b><b>, SIM_get_register_name</b> &#8212; convert between register name and register number</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_get_register_number(conf_object_t *cpu, const char *name);
</pre><pre class="jdocu_small" style="color: black">const char *
SIM_get_register_name(conf_object_t *cpu, int reg);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions convert a given register number to the register name or
   vice versa. Name to number conversion functions are not case sensitive.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>

   <b>General</b> If the register name is not found.
   <b>Index</b> If <i>reg</i> index is out of range
   </dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Register index or string pointer to name.
   </dd>
</dl>
<a name="label739"></a><h6 class="jdocu">SIM_number_processors()</h6 class="jdocu">

<a name="label740"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label741"></a><b>SIM_number_processors</b> &#8212; number of processors</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_number_processors(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the current total number of processors in the system.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Number of processors.</dd>
</dl>
<a name="label742"></a><h6 class="jdocu">SIM_processor_enabled()</h6 class="jdocu">

<a name="label743"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label744"></a><b>SIM_processor_enabled</b> &#8212; check if processor is enabled</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_processor_enabled(conf_object_t *cpu);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns 1 if the processor is enabled, or 0 if it is disabled.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
1 if enabled, else 0.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label713">SIM_enable_processor</a></dl>
<a name="label745"></a><h6 class="jdocu">SIM_processor_privilege_level()</h6 class="jdocu">

<a name="label746"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label747"></a><b>SIM_processor_privilege_level</b> &#8212; return the current privilege level for a processor</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_processor_privilege_level(conf_object_t *cpu);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return the current privilege level for a processor.  The definition
  of privilege levels depends on the processor type.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>

  For SPARC, and PowerPC, and ARM processors: 0 for User mode, and
  1 for Supervisor mode.<br>
  For x86 and IA-64 processors: 0-3, where 0 is the most privileged.<br>
  For Alpha processors: 0 for kernel mode, 1 for executive mode, and 3
  for user mode.<br>
  For MIPS processors: 0
  </dd>
</dl>
<a name="label748"></a><h6 class="jdocu">SIM_read_register()</h6 class="jdocu">

<a name="label749"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label750"></a><b>SIM_read_register</b> &#8212; get register value</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">uinteger_t
SIM_read_register(conf_object_t *cpu, int reg);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the value of the specified processor register.
<p>
   For the ARM target, this function returns the value of the register in the
   bank corresponding to the current mode. To access copies of the register in
   other banks, use the <b><i>read_register_mode</i></b> function in the
   <tt>arm</tt> interface.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>

   <b>Index</b> Thrown if <i>reg</i> is out of range.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Value from the register.</dd>
</dl>
<a name="label751"></a><h6 class="jdocu">SIM_register_arch_decoder()</h6 class="jdocu">

<a name="label752"></a><a name="label753"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label754"></a><b>SIM_register_arch_decoder</b><b>, SIM_unregister_arch_decoder</b> &#8212; install/uninstall instruction decoders</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_register_arch_decoder(decoder_t *decoder,
                          const char *arch, int arch_mode);
</pre><pre class="jdocu_small" style="color: black">void
SIM_unregister_arch_decoder(decoder_t *decoder,
                            const char *arch, int arch_mode);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_register_arch_decoder</i></b> makes it possible to install
  instruction decoders in Simics. This allows adding instructions, or
  replacing existing instructions with new
  implementations.
<p>
  <b><i>SIM_unregister_arch_decoder</i></b> unregisters decoders registered with
  <b><i>SIM_register_arch_decoder</i></b>. <b><i>SIM_unregister_arch_decoder</i></b>
  must not be called while an instruction is executing. This is the case the
  <b><i>decode</i></b> and service routine functions of instruction decoders, in
  the <b><i>operate</i></b> function of the <tt>timing-model</tt> interface,
  and in the <b><i>operation</i></b> function of the <tt>io-memory</tt>
  interface. It is also the case for callbacks for some haps. In these cases,
  post an event using <b><i>SIM_stacked_post</i></b> and unregister the decoder
  from the event handler.
<p>
  When Simics decodes an instruction, it will first see if any
  instruction decoders are registered for the current architecture.
  For any decoders it finds, Simics will let it try to decode the
  instruction.  The decoders are called in order, starting with the
  last registered decoder, and if one decoder accepts the instruction,
  the rest of the decoders will not be called.
<p>
  When a decoder accepts an instruction, it creates a structure
  describing the decoded instruction, including a pointer to a
  function that Simics will call each time the instruction is
  executed.
<p>
  <i>decoder</i> is the decoder to register
<p>
  <i>arch</i> is the target architecture that the decoder can
  decode instruction for.  It is matched against the
  <i>architecture</i> attribute on CPU objects to determine
  whether the decoder applies.  It can also be given as <tt>NULL</tt>,
  which means that the decoders will be used for all CPU
  architectures.  The simplest way to find the value to use is to load
  a configuration into Simics and check the value of the
  <i>architecture</i> attribute in the CPU object.
<p>
  <i>arch_mode</i> is the instruction mode of the
  architecture.  This should always be 0.
<p>
  The <tt>decoder_t</tt> type is a structure providing the
  functions used to invoke the decoder.
  
   <pre class="jdocu_small" style="color: black">typedef struct {
        void *user_data;
        int (*NOTNULL decode)(unsigned char *code,
                              int valid_bytes,
                              conf_object_t *cpu,
                              instruction_info_t *ii,
                              void *user_data);
        int (*NOTNULL disassemble)(unsigned char *code,
                                   int valid_bytes,
                                   conf_object_t *cpu,
                                   char *buffer,
                                   void *user_data);
        int (*NOTNULL flush)(conf_object_t *cpu,
                             instruction_info_t *ii,
                             void *user_data);
} decoder_t;</pre>
<p>
   <a name="label755"></a>
<p>
   The <b><i>decode</i></b> function is called to decode an instruction
   pointed to by <i>code</i>.  The first byte represents the
   lowest address of the instruction in the simulated
   memory. <i>valid_bytes</i> tells how many bytes can be
   read.  The current CPU is given in the <i>cpu</i>
   parameter.  When the decoder has successfully decoded the
   instruction, it fills in the <i>ii</i> structure, and
   returns the number of bytes used in the decoding.  If it does not
   apply to the given instruction, it should return zero.  If the
   decoder needs more data it should return a negative number
   corresponding to the total number of bytes needed. Simics will then
   call the decoder again with more available bytes. This process is
   repeated until the decoder accepts or rejects the instruction.
<p>
   Note that in a shared memory multiprocessor, the <i>cpu</i>
   used in decoding may differ from the CPU that executes the
   instruction, since the decoded instructions are cached by Simics.
<p>
   The <b><i>disassemble</i></b> function is called to disassemble an
   instruction.  It uses the same <i>code</i>,
   <i>valid_bytes</i>, and <i>cpu</i> parameters as
   the <b><i>decode</i></b> function.  In addition, it takes a pointer to
   a string buffer, <i>buffer</i>.  The disassembly should be
   written to this buffer as a null-terminated string with a maximum
   length of 256 characters, including the null terminator.  The
   return value is handled identically to the that of the
   <b><i>decode</i></b> function.
<p>
   The <b><i>flush</i></b> function is called to free any memory allocated when
   decoding an instruction, including the register info array.  Just like the
   other functions, it should return zero if it doesn't recognize the
   instruction, and non-zero if it has handled it.  Usually, the way to
   recognize if a decoded instruction is the right one is to compare
   <tt>ii-&gt;ii_ServiceRoutine</tt> with what is set in the <i>decode</i>
   function. Note that the <i>cpu</i> parameter is the processor that
   caused the flush. It is more or less an arbitrary processor and should be
   ignored.
<p>
   In addition to the function pointers, the structure contains a
   <i>user_data</i> pointer that is passed to all the
   functions.  This can be used for passing any data to the decoder
   functions.
<p>
   The <tt>instruction_info_t</tt> is defined like this.
<p>
   
   <pre class="jdocu_small" style="color: black">typedef struct instruction_info {
        service_routine_t  ii_ServiceRoutine;
        unsigned int       ii_Arg;
        unsigned int       ii_Type;
        reg_info_t        *ii_RegInfo;
        lang_void         *ii_UserData;
        logical_address_t  ii_LogicalAddress;
        physical_address_t ii_PhysicalAddress;
} instruction_info_t;</pre>
<p>
   <a name="label756"></a>
<p>
   <i>ii_ServiceRoutine</i> is a pointer to a service routine to
   be called by Simics every time the instruction is executed. It has
   the following prototype:
   <p>
   
   <pre class="jdocu_small" style="color: black">typedef exception_type_t (*service_routine_t)(conf_object_t *cpu, 
                                              unsigned int arg, 
                                              lang_void *user_data);</pre>
<a name="label757"></a>
    
<p>
   <i>ii_Arg</i> is the argument that will be passed on to the
   service routine. It typically contains a bit-field of parameters to
   the instruction such as register numbers or intermediate
   values. It can also be a pointer to a structure if more appropriate.
   <p>
   <i>ii_Type</i> is either <tt>UD_IT_SEQUENTIAL</tt> or
   <tt>UD_IT_CONTROL_FLOW</tt>.  A sequential type means that the
   instruction does not perform any branches and the update of the
   program counter(s) is handled by Simics. In a control flow
   instruction on the other hand it is up to the user to set the
   program counter(s).
<p>
   <i>ii_RegInfo</i> should be used if Simics is running in
   out of order mode. An array of <tt>reg_info_t</tt> should be
   allocated that describes the registers the instruction uses and if
   they are used as input and/or output. The array should be
   terminated with a dummy register (<i>id</i> equal to 0) which
   is neither input nor output (<i>in</i> and <i>out</i> both
   zero).
<p>
   <a name="label758"></a>
<pre class="jdocu_small" style="color: black">struct reg_info {
        register_type_t type;   /* register type */
        register_id_t id;       /* register id */
        unsigned input:1;       /* used as input */
        unsigned output:1;      /* used as output */
};</pre>
<a name="label759"></a>
<pre class="jdocu_small" style="color: black">typedef struct reg_info reg_info_t;</pre>

<p>
   The <i>register_id</i> of the PC(s) should not be filled in,
   Simics handles that automatically. If the instruction manipulates a
   register not listed the value <tt>Sim_RI_Sync</tt> should be
   used, this will disallow the instruction to run out of order.
<p>
   The array needs to be deallocated when the instruction is
   flushed, see below.
<p>
   <i>ii_UserData</i> can be filled in with
   other data.
<p>
   The service routine function should return an exception when it is
   finished to signal its status. If no exception occurs
   <tt>Sim_PE_No_Exception</tt> should be returned.
<p>
   See <tt>exception_type_t</tt> in <tt>core/types.h</tt> for
   the different exceptions available.
<p>
   A special return value, <tt>Sim_PE_Default_Semantics</tt>, can be
   returned; this signals Simics to run the default semantics for the
   instruction. This is useful if the semantics of an instruction
   should be changed but the user routine does not want to handle it all
   the time.
<p>
   
<p>
   </dd>

<p>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
See the source code for the example extension
  <i>sample-user-decoder</i> in
  <tt>[simics]/src/extensions</tt>.</dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>General</b> Thrown if the same decoder is
  registered twice for the same architecture.
<p>
  <b>IllegalValue</b> Thrown if the decoder doesn't have all function
  pointers set.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="topic7.html#label194">register_id_t</a></dl>
<a name="label760"></a><h6 class="jdocu">SIM_register_decoder()</h6 class="jdocu">

<a name="label761"></a><a name="label762"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label763"></a><b>SIM_register_decoder</b><b>, SIM_unregister_decoder</b> &#8212; deprecated install/uninstall user decoders</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_register_decoder(user_decoder_t decoder);
</pre><pre class="jdocu_small" style="color: black">void
SIM_unregister_decoder(user_decoder_t decoder);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions are obsolete, use the
  <b><i>SIM_register_arch_decoder</i></b> and
  <b><i>SIM_unregister_arch_decoder</i></b> functions instead.
<p>
  SIM_register_decoder makes it possible to install user decoders in
  Simics. This gives the user an interface to the instruction set
  allowing changes to the instructions semantics, adding new
  instructions or removing implemented ones.
<p>
  When simics decodes an instructions it will first see if any user
  decoder is supplied and in that case call it first. Several decoders
  can be installed and Simics will call them in the reverse order they
  were registered; i.e., the last one first. Every decoder has the
  option of either accepting the opcode given or pass it on to the
  next decoder.
<p>
  If a decoder accepts the instruction it fills in an information structure which contains
  a function pointer that Simics will call each time the instruction should be executed.
<p>
  <tt>user_decoder</tt> is the decoder to register, it is defined like this:
  
   <pre class="jdocu_small" style="color: black">typedef int (*NOTNULL user_decoder_t)(unsigned char *code,
                                      int valid_bytes,
                                      conf_object_t *cpu,
                                      instruction_info_t *ii,
                                      int action,
                                      char *string_buffer);</pre>
<p>
   <a name="label764"></a>
<p>
   <tt>code</tt> is a pointer to the instruction to decode.  The first
   byte represents the lowest address of the instruction in the
   simulated memory. <tt>valid_bytes</tt> tells how many bytes
   can be read.  If the decoder needs more data it should return a
   negative number corresponding to the total number of bytes
   needed. Simics will then call the decoder again with more available
   bytes. This process is repeated until the decoder accepts or
   rejects the instruction. If the instruction is accepted its length
   in bytes should be returned, otherwise zero.
<p>
   <tt>cpu</tt> is the cpu decoding the instruction. Note that in
   a shared memory multiprocessor, this may differ from the one executing
   the instruction since decoded instructions are cached. 
<p>
   <tt>action</tt> is whether Simics wants to decode, disassemble or
   flush a previously decoded instruction. For decoding, the value is
   <tt>UD_ACTION_DECODE</tt> and the instruction_info_t structure
   <tt>ii</tt> should be filled in. The structure has the following
   fields:
<p>
   
   <pre class="jdocu_small" style="color: black">typedef struct instruction_info {
        service_routine_t  ii_ServiceRoutine;
        unsigned int       ii_Arg;
        unsigned int       ii_Type;
        reg_info_t        *ii_RegInfo;
        lang_void         *ii_UserData;
        logical_address_t  ii_LogicalAddress;
        physical_address_t ii_PhysicalAddress;
} instruction_info_t;</pre>
<p>
   <a name="label765"></a>
<p>
   <i>ii_ServiceRoutine</i> is a pointer to a service routine to
   be called by Simics every time the instruction is executed. It has
   the following prototype:
   <p>
   
   <pre class="jdocu_small" style="color: black">typedef exception_type_t (*service_routine_t)(conf_object_t *cpu, 
                                              unsigned int arg, 
                                              lang_void *user_data);</pre>
<a name="label766"></a>
    
<p>
   <i>ii_Arg</i> is the argument that will be passed on to the
   service routine. It typically contains a bit-field of parameters to
   the instruction such as register numbers or intermediate
   values. It can also be a pointer to a structure if more appropriate.
   <p>
   <i>ii_Type</i> is either <tt>UD_IT_SEQUENTIAL</tt> or
   <tt>UD_IT_CONTROL_FLOW</tt>.  A sequential type means that the
   instruction does not perform any branches and the update of the
   program counter(s) is handled by Simics. In a control flow
   instruction on the other hand it is up to the user to set the
   program counter(s).
<p>
   <i>ii_RegInfo</i> should be used if Simics is running in
   out of order mode. An array of <tt>reg_info_t</tt> should be
   allocated that describes the registers the instruction uses and if
   they are used as input and/or output. The array should be
   terminated with a dummy register (<i>id</i> equal to 0) which
   is neither input nor output (<i>in</i> and <i>out</i> both
   zero).
<p>
   <a name="label767"></a>
<pre class="jdocu_small" style="color: black">struct reg_info {
        register_type_t type;   /* register type */
        register_id_t id;       /* register id */
        unsigned input:1;       /* used as input */
        unsigned output:1;      /* used as output */
};</pre>
<a name="label768"></a>
<pre class="jdocu_small" style="color: black">typedef struct reg_info reg_info_t;</pre>

<p>
   The <i>register_id</i> of the PC(s) should not be filled in,
   Simics handles that automatically. If the instruction manipulates a
   register not listed the value <tt>Sim_RI_Sync</tt> should be
   used, this will disallow the instruction to run out of order.
<p>
   The array needs to be deallocated when the instruction is
   flushed, see below.
<p>
   <i>ii_UserData</i> can be filled in with
   other data.
<p>
   The service routine function should return an exception when it is
   finished to signal its status. If no exception occurs
   <tt>Sim_PE_No_Exception</tt> should be returned.
<p>
   See <tt>exception_type_t</tt> in <tt>core/types.h</tt> for
   the different exceptions available.
<p>
   A special return value, <tt>Sim_PE_Default_Semantics</tt>, can be
   returned; this signals Simics to run the default semantics for the
   instruction. This is useful if the semantics of an instruction
   should be changed but the user routine does not want to handle it all
   the time.
<p>
   
<p>
   If Simics wants to disassemble the instruction the <tt>action</tt>
   value will be <tt>UD_ACTION_DISASS</tt> and the <tt>string_buffer</tt>
   should be filled with the disassembled instruction (max length is
   256 characters). The <tt>ii</tt> structure should be ignored.
<p>
   A value of UD_ACTION_FLUSH (code and string_buffer will be null,
   valid_bytes zero) means that Simics wants to flush a cached decoded
   instruction. The instruction_info_t structure <tt>ii</tt> will then
   hold the values previously stored there. If the user-decoder
   recognizes the <tt>ii-&gt;ii_ServiceRoutine</tt> function as its own
   it should now free all allocated user data including the register
   info array, if allocated, and return a non-zero value to indicate
   success. Otherwise zero should be returned letting other
   user-decoders have a shot.
<p>
   
<p>
  Use SIM_unregister_decoder to remove a user-decoder.</dd>

<p>
<dt class="jdocu_descitem">EXAMPLE</dt><dd>
See the source code for the example extension
  <i>decoder</i>.</dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label754">SIM_register_arch_decoder</a></dl>
<a name="label769"></a><h6 class="jdocu">SIM_reset_processor()</h6 class="jdocu">

<a name="label770"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label771"></a><b>SIM_reset_processor</b> &#8212; reset the processor</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_reset_processor(conf_object_t *cpu, int hard_reset);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Performs a reset on the processor, causing a System Reset exception to be taken
   when execution continues. <i>cpu</i> is the processor that should be reset.
   <i>hard_reset</i> indicates if a soft (0) or hard (1) (power-on type) reset should be performed.
   If a hard reset is requested, a number of register are initiated with default values.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>General</b> Thrown if <i>cpu</i> does not
   implement reset.<br>
   </dd>
</dl>
<a name="label772"></a><h6 class="jdocu">SIM_write_register()</h6 class="jdocu">

<a name="label773"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label774"></a><b>SIM_write_register</b> &#8212; set register value</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_write_register(conf_object_t *cpu, int reg, uinteger_t value);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Sets the value of the specified processor register.
<p>
   For the ARM target, this function sets the value of the register in the
   bank corresponding to the current mode. To access copies of the register in
   other banks, use the <b><i>write_register_mode</i></b> function in the
   <tt>arm</tt> interface.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>

   <b>Index</b> Thrown if <i>reg</i> is out of range.</dd>
</dl>

<a name="label775"></a><h5 class="jdocu">Profiling</h5 class="jdocu">
<a name="label776"></a><h6 class="jdocu">SIM_iter_next()</h6 class="jdocu">

<a name="label777"></a><a name="label778"></a><a name="label779"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label780"></a><b>SIM_iter_next</b><b>, SIM_iter_addr</b><b>, SIM_iter_free</b> &#8212; Iterate over address profile counters</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">FORCE_INLINE uint64
SIM_iter_next(addr_prof_iter_t *iter);
</pre><pre class="jdocu_small" style="color: black">FORCE_INLINE generic_address_t
SIM_iter_addr(addr_prof_iter_t *iter);
</pre><pre class="jdocu_small" style="color: black">FORCE_INLINE void
SIM_iter_free(addr_prof_iter_t *iter);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>

<p>
   <b>EXPERIMENTAL.</b> While this functionality is expected to be retained in
   future releases, the interface is likely to change.
<p>
   
<p>
   

   An address profile iterator visits some of the counters of an address
   profiler in some order. It is obtained from the <b><i>iter</i></b> function of
   the <tt>address_profiler</tt> interface.
<p>
   <b><i>SIM_iter_next</i></b> advances the address profile iterator
   <i>iter</i> to the next nonzero counter and returns the count. It
   will return 0 when there are no more counters to visit. Note that the order
   in which the counters are visited is unspecified.
<p>
   <b><i>SIM_iter_addr</i></b> returns the address of the counter returned by the
   most recent call to <b><i>iter_next</i></b>.
<p>
   When you are done with the iterator, deallocate it with
   <b><i>SIM_iter_free</i></b>.</dd>

<p>
</dl>

<a name="label781"></a><h5 class="jdocu">Simulation Control</h5 class="jdocu">
<a name="label782"></a><h6 class="jdocu">SIM_break_message()</h6 class="jdocu">

<a name="label783"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label784"></a><b>SIM_break_message</b> &#8212; stop the simulation</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_break_message(const char *msg);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Display the reason why Simics will stop simulation.
<p>
   This is similar to <b><i>SIM_break_simulation</i></b>, with the
   difference that it doesn't actually break the simulation. It can be
   used by code that wants to display a break message and stop the
   simulation by some other means.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label787">SIM_break_simulation</a></dl>
<a name="label785"></a><h6 class="jdocu">SIM_break_simulation()</h6 class="jdocu">

<a name="label786"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label787"></a><b>SIM_break_simulation</b> &#8212; stop the simulation</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_break_simulation(const char *msg);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Ask Simics to stop the simulation as soon as possible, displaying the
   supplied message.
<p>
   Simics will normally stop before the next instruction is executed.
   If this function is called when an instruction has started
   executing, and the instruction can be aborted, it will rewind to
   before the instruction.  This might leave the simulation is a state
   where some repeatable part of the instruction is already executed.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label784">SIM_break_message</a></dl>
<a name="label788"></a><h6 class="jdocu">SIM_continue()</h6 class="jdocu">

<a name="label789"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label790"></a><b>SIM_continue</b> &#8212; continue the simulation</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">pc_step_t
SIM_continue(integer_t steps);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Runs the simulation the specified number of <i>steps</i> on the
   current CPU. Since Simics is scheduling the processors in a round-robin
   fashion, other CPUs may run as well. This happens if <i>steps</i>
   is greater than what is left of the current CPU's time quantum.
   Simics will then run the other CPUs for their time quanta and then return
   to to the first CPU executing the remaining steps.
   This can happen several times if steps cover several time quanta.
<p>
   The function may return before completing <i>steps</i> steps if a
   breakpoint is reached, user code requests the simulation to be interrupted,
   or execution is interrupted via the user interface. 
   In such cases the current CPU may have
   changed (see <b><i>SIM_current_processor()</i></b>) since Simics may have been
   executing in another processor's time quantum.
<p>
   If <i>steps</i> is 0, Simics will run forever or until it is
   interrupted as described above.
<p>
   If this function is called from a context where simulation cannot continue,
   e.g., from a callback function passed to <b><i>SIM_post_command()</i></b>,
   <b><i>SIM_continue()</i></b> will return immediately with return value 0 but
   the simulation will not be started until the calling function has
   exited. If this is the case, any exceptions returned from the simulation
   core will be discarded but the return value from the simulation can be
   read as an argument to the <tt>Core_Simulation_Stopped</tt> hap.
   You can query whether the current state will result in such a postponed
   continuation by calling the <b><i>SIM_postponing_continue()</i></b> function.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
The number of steps actually executed
   </dd>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>General</b> Thrown if <i>steps</i>
    has illegal value, a breakpoint is reached, or Simics already was running.
   </dd>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label885">SIM_post_command</a>, <a class="jdocu" href="#label793"> SIM_postponing_continue</a>,  
   Core_Simulation_Stopped</dl>
<a name="label791"></a><h6 class="jdocu">SIM_postponing_continue()</h6 class="jdocu">

<a name="label792"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label793"></a><b>SIM_postponing_continue</b> &#8212; ask if continue will be postponed</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_postponing_continue(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function returns non-zero if calls to <b><i>SIM_continue()</i></b>
   would return immediately, postponing the actual call to the Simics core.</dd>

<p>
</dl>
<a name="label794"></a><h6 class="jdocu">SIM_simics_is_running()</h6 class="jdocu">

<a name="label795"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label796"></a><b>SIM_simics_is_running</b> &#8212; check if Simics is running</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_simics_is_running(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns 1 if simics is running, i.e., executing target instructions,
   or 0 otherwise.</dd>

<p>
</dl>

<a name="label797"></a><h5 class="jdocu">Simulation Independent Services</h5 class="jdocu">
<a name="label798"></a><h6 class="jdocu">SIM_cancel_realtime_event()</h6 class="jdocu">

<a name="label799"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label800"></a><b>SIM_cancel_realtime_event</b> &#8212; cancel callback in host time</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_cancel_realtime_event(integer_t id);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Cancel a callback registered by <b><i>SIM_realtime_event</i></b>, whose
   return value is specified as <i>id</i>.
<p>
   Returns 0 if the callback existed and was cancelled, or -1 if no callback
   with that identifier existed. (No exception is raised.)</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label809">SIM_realtime_event</a></dl>
<a name="label801"></a><h6 class="jdocu">SIM_notify_on_socket()</h6 class="jdocu">

<a name="label802"></a><a name="label803"></a><a name="label804"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label805"></a><b>SIM_notify_on_socket</b><b>, SIM_notify_on_object</b><b>, SIM_notify_on_descriptor</b> &#8212; register notification on host I/O events</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_notify_on_socket(int sock, notify_mode_t mode, int run_in_thread,
                     void (*callback)(lang_void *data), lang_void *data);
</pre><pre class="jdocu_small" style="color: black">void
SIM_notify_on_object(HANDLE obj, int run_in_thread,
                     void (*callback)(lang_void *data), lang_void *data);
</pre><pre class="jdocu_small" style="color: black">void
SIM_notify_on_descriptor(int fd, notify_mode_t mode, int run_in_thread,
                         void (*callback)(lang_void *data),
                         lang_void *data);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions allows the function <i>callback</i> to be called
   with argument <i>data</i> whenever a specific I/O event occurs on
   the host machine. If <i>callback</i> is a null function pointer,
   a previously installed notification is removed.
<p>
   If <i>run_in_thread</i> is nonzero, the callback function may be run
   in a thread where it cannot access or call anything in Simics except for
   these functions and <b><i>SIM_thread_safe_callback</i></b>. If
   <i>run_in_thread</i> is zero, the callback function is always run in
   the main thread. This may incur a small penalty in latency (time between the
   occurrence of the host event and execution of <i>callback</i>).
<p>
   Notification on a specific event will be blocked during the execution of
   its callback function.
<p>
   <b><i>SIM_notify_on_socket</i></b> will call a registered callback depending
   on <i>mode</i>:
<p>
   <table>
<tr><td class="jdocu_noborder"><i>mode</i></td><td class="jdocu_noborder">condition</td></tr>
<tr><td class="jdocu_noborder"><tt>Sim_NM_Read</tt></td><td class="jdocu_noborder">Socket is readable, closed, or incoming connection accepted</td></tr>
<tr><td class="jdocu_noborder"><tt>Sim_NM_Write</tt></td><td class="jdocu_noborder">Socket is writeable, or outgoing connection has completed</td></tr>
</table>
   <a name="label806"></a>
<p>
   <b>Unix only</b>: <b><i>SIM_notify_on_descriptor</i></b> will call a
   registered callback depending on <i>mode</i> for a given file
   descriptor in a way similar to <b><i>SIM_notify_on_socket</i></b>.
<p>
   <b>Windows only</b>: <b><i>SIM_notify_on_object</i></b> will call a registered
   callback when <i>object</i> (which must be a waitable object) is in
   signalled state. The signalling object is modified in the same way as
   the Windows wait functions (<b><i>WaitForMultipleObjects</i></b> etc).
<p>
   <hr class="jdocu_note"><b>Note:</b> A notification should be removed before its socket or descriptor is
   closed.<hr class="jdocu_note"></dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label812">SIM_thread_safe_callback</a></dl>
<a name="label807"></a><h6 class="jdocu">SIM_realtime_event()</h6 class="jdocu">

<a name="label808"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label809"></a><b>SIM_realtime_event</b> &#8212; schedule callback in host time</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">integer_t
SIM_realtime_event(unsigned delay, void (*callback)(lang_void *data),
                   lang_void *data, int run_in_thread, const char *desc);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Register <i>callback</i> to be run in <i>delay</i> ms, with
   argument <i>data</i>. The delay is in real time (on the host
   machine), and the actual delay may be somewhat larger because of host
   scheduling.
<p>
   If <i>run_in_thread</i> is nonzero, the callback may be run in a
   thread where it cannot access or call anything in Simics except for
   <b><i>SIM_thread_safe_callback</i></b>. If <i>run_in_thread</i> is
   zero, the callback function is always run in the main thread. This may
   cause the call to occur slightly later than requested, depending on what
   Simics is doing at the time.
<p>
   The <i>desc</i> parameter is only present for debugging and has no
   other effect; it should be a static string describing the callback but may
   also be left NULL if desired.
<p>
   The callback is only called once.
<p>
   The return value is a non-zero identifier that can be used to cancel the
   callback using <b><i>SIM_cancel_realtime_event</i></b>.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label800">
       SIM_cancel_realtime_event</a>, <a class="jdocu" href="#label812"> SIM_thread_safe_callback
   </a></dl>
<a name="label810"></a><h6 class="jdocu">SIM_thread_safe_callback()</h6 class="jdocu">

<a name="label811"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label812"></a><b>SIM_thread_safe_callback</b> &#8212; call function synchronized with main thread</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_thread_safe_callback(void (*f)(lang_void *data), lang_void *data);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This is the <i>only</i> function in the Simics API that can be called from
   threads other than the main simics thread. Failure to abide by this rule
   will result in undefined behavior. The user should not make any assumptions
   about when the supplied function is called. It may be called immediately,
   but it may also be called after this function has returned.</dd>

<p>
</dl>

<a name="label813"></a><h5 class="jdocu">Simulator Translation Caches</h5 class="jdocu">
<a name="label814"></a><h6 class="jdocu">SIM_STC_flush_cache()</h6 class="jdocu">

<a name="label815"></a><a name="label816"></a><a name="label817"></a><a name="label818"></a><a name="label819"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label820"></a><b>SIM_STC_flush_cache</b><b>, SIM_flush_I_STC_logical</b><b>, SIM_flush_D_STC_logical</b><b>, SIM_flush_I_STC_physical</b><b>, SIM_flush_D_STC_physical</b> &#8212; flush or remove entries in the STCs of a cpu</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_STC_flush_cache(conf_object_t *cpu);
</pre><pre class="jdocu_small" style="color: black">void
SIM_flush_I_STC_logical(conf_object_t *cpu,
                        logical_address_t vaddr,
                        logical_address_t length);
</pre><pre class="jdocu_small" style="color: black">void
SIM_flush_D_STC_logical(conf_object_t *cpu,
                        logical_address_t vaddr,
                        logical_address_t length);
</pre><pre class="jdocu_small" style="color: black">void
SIM_flush_I_STC_physical(conf_object_t *cpu,
                         physical_address_t paddr,
                         physical_address_t length);
</pre><pre class="jdocu_small" style="color: black">void
SIM_flush_D_STC_physical(conf_object_t *cpu,
                         physical_address_t paddr,
                         physical_address_t length,
                         read_or_write_t read_or_write);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions remove entries from the Simics internal caches (STCs) or
   completely flushes the STCs contents. Memory mappings which have been
   cached in the STCs will be faster for Simics to execute. Simics
   extensions such as a cache model will need to flush entries in the STC
   when a cache line is replaced, in order to be called when a cache line
   is used again.
   <p>
   <b><i>SIM_STC_flush_cache()</i></b> flushes the entire contents of the STCs
   (both instruction and data) from the specified cpu.
<p>
   The <b><i>SIM_flush_<em>xxx</em></i></b> functions removes specified memory
   ranges in the instruction or data STC. The address range is either the
   logical or the physical address. The <tt>read_or_write</tt> parameter
   specifies whether the read or the write D-STC should be flushed. If the
   function doesn't have such a parameter, both read and write D-STCs are
   flushed. The flushed address range is at least [ <i>vaddr</i>
   ... (<i>vaddr</i> + <i>length</i> &minus; 1) ], but may be larger.
   <b><i>SIM_flush_D_STC_logical()</i></b> currently always flushes an entire
   page.</dd>

<p>
</dl>
<a name="label821"></a><h6 class="jdocu">SIM_flush_all_caches()</h6 class="jdocu">

<a name="label822"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label823"></a><b>SIM_flush_all_caches</b> &#8212; clear Simics's internal caches</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_flush_all_caches(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Clears Simics's internal caches such as STC contents and intermediate code.
   This function is mainly for Virtutech internal use (for debugging purposes)
   and may be removed in the future.</dd>

<p>
</dl>

<a name="label824"></a><h5 class="jdocu">Stalling</h5 class="jdocu">
<a name="label825"></a><h6 class="jdocu">SIM_release_stall()</h6 class="jdocu">

<a name="label826"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label827"></a><b>SIM_release_stall</b> &#8212; release stalling transaction</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_release_stall(conf_object_t *obj, int id);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Sometimes the stalling period of an memory transaction is not known
   by the timing model. This can happen for example if the transaction
   is blocked by another transaction. In such case a very long
   stall-time can be returned to block the transaction. As soon as the
   timing model finds out when the stalling is over the memory
   transaction needs to be released.
<p>
   This function changes the stalling period for a memory transaction with id
   <i>id</i> on CPU <i>cpu</i> to zero. This means that
   the memory transaction may be issued the second time in the next cycle.</dd>

<p>
<dt class="jdocu_descitem">NOTE</dt><dd>
Only useful if Simics is running in out of order mode.</dd>
</dl>
<a name="label828"></a><h6 class="jdocu">SIM_stall_count()</h6 class="jdocu">

<a name="label829"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label830"></a><b>SIM_stall_count</b> &#8212; get number of cycles a processor has been stalled</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">cycles_t
SIM_stall_count(conf_object_t *obj);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_stall_count</i></b> returns the total number of cycles the
   processor associated to <i>obj</i> has been stalled.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>

   <b>General</b> Thrown if <i>obj</i> is <tt>NULL</tt>.
   </dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>

   Returns the total number of cycles the processor associated with
   <i>obj</i> has been stalled.
   </dd>
</dl>
<a name="label831"></a><h6 class="jdocu">SIM_stall_cycle()</h6 class="jdocu">

<a name="label832"></a><a name="label833"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label834"></a><b>SIM_stall_cycle</b><b>, SIM_stall</b> &#8212; stall execution a specified number of cycles</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_stall_cycle(conf_object_t *obj, cycles_t cycles);
</pre><pre class="jdocu_small" style="color: black">void
SIM_stall(conf_object_t *obj, double seconds);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
SIM_stall_cycle sets the stall time at <i>obj</i>. <i>cycles</i>
   is the number of clock cycles the processor will stall. A call to this
   function will overwrite the current time left to stall at obj. No
   compensation is made if time differs between obj and where the function
   is called from.
<p>
   SIM_stall does the same thing as SIM_stall_cycle but the stall time is 
   given in seconds.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>

   <b>General</b> Thrown if <i>obj</i> is <tt>NULL</tt>.<br>
   <b>General</b> Thrown if <i>cycles</i> or <i>seconds</i> is negative.
   </dd>
</dl>
<a name="label835"></a><h6 class="jdocu">SIM_stalled_until()</h6 class="jdocu">

<a name="label836"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label837"></a><b>SIM_stalled_until</b> &#8212; query how many cycles that remains of stall</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">cycles_t
SIM_stalled_until(conf_object_t *obj);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_stalled_until</i></b> returns how many more cycles the
   processor will stall before the associated processor starts to
   execute instructions again.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>

   <b>General</b> Thrown if <i>obj</i> is <tt>NULL</tt>.
   </dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
 
   Number of cycles remaining of stall.
   </dd>
</dl>

<a name="label838"></a><h5 class="jdocu">Step and Time Events</h5 class="jdocu">
<a name="label839"></a><h6 class="jdocu">SIM_cycle_count()</h6 class="jdocu">

<a name="label840"></a><a name="label841"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label842"></a><b>SIM_cycle_count</b><b>, SIM_time</b> &#8212; query time queue for current time</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">cycles_t  
SIM_cycle_count(conf_object_t *obj);
</pre><pre class="jdocu_small" style="color: black">double
SIM_time(conf_object_t *obj);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_cycle_count</i></b> returns current simulated clock cycle
   count at <i>obj</i>. Note that if processors are running at
   different frequency, the number will differ between processors,
   regardless of simulation quantum effects.
<p>
   <b><i>SIM_time</i></b> returns current time at <i>obj</i>. Time is
   counted in seconds and has a maximum resolution of one clock cycle.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>

   <b>General</b> Thrown if <i>obj</i> is <tt>NULL</tt>.
   </dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
 
   <b><i>SIM_cycle_count</i></b> returns the current time in number of
   cycles. <b><i>SIM_time</i></b> returns the current time in seconds as
   a floating point value.
   </dd>
</dl>
<a name="label843"></a><h6 class="jdocu">SIM_next_queue()</h6 class="jdocu">

<a name="label844"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label845"></a><b>SIM_next_queue</b> &#8212; get next object that owns a queue</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">conf_object_t* 
SIM_next_queue(conf_object_t *obj);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the next object that owns an event queue. This
   function can be used to iterate over all step and time queues.
   Passing a NULL argument will return the first object. When
   given the last object it will return NULL.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
 <b>General</b> Object does not own an event
    queue.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Next object that owns an event queue or NULL
    if last.</dd>
<dt class="jdocu_descitem">BUGS</dt><dd>
There is no check that <i>obj</i> owns a queue, which
    it must.</dd>
</dl>
<a name="label846"></a><h6 class="jdocu">SIM_stacked_post()</h6 class="jdocu">

<a name="label847"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label848"></a><b>SIM_stacked_post</b> &#8212; insert an event that runs as soon as possible</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void 
SIM_stacked_post(conf_object_t *obj,
                 event_handler_t func,
                 lang_void *user_data);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <i>func</i> function will be called with <i>obj</i> and
   <i>user_data</i> as arguments as soon as the current instruction has
   completed. <b><i>SIM_stacked_post</i></b> will call the function after the
   current instruction or event handler has returned.
<p>
   Time is undefined when the function is called. If several functions are
   registered this way before any of them has had a chance to run, the last
   registered will run first.
<p>
   This call is mainly useful for actions that for various reasons cannot be
   done inside an instruction.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>General</b> Thrown if <i>obj</i>
   or <i>func</i> is <tt>NULL</tt>.</dd>
</dl>
<a name="label849"></a><h6 class="jdocu">SIM_step_clean()</h6 class="jdocu">

<a name="label850"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label851"></a><b>SIM_step_clean</b> &#8212; remove events from the step queue</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void 
SIM_step_clean(conf_object_t *obj, 
               event_handler_t func,
               typed_lang_void *user_data);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
SIM_step_clean removes all events in the step queue associated
   with <i>obj</i> that match <i>func</i> and <i>user_data</i>.
   If user_data is <tt>NULL</tt> it will match any parameter
   thus removing all matching handlers regardless of their parameter.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>General</b> Thrown if <i>obj</i>
   or <i>func</i> is <tt>NULL</tt>.</dd>
</dl>
<a name="label852"></a><h6 class="jdocu">SIM_step_count()</h6 class="jdocu">

<a name="label853"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label854"></a><b>SIM_step_count</b> &#8212; query step queue count</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">pc_step_t
SIM_step_count(conf_object_t *obj);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
SIM_step_count returns the number of executed program counter steps at
   <i>obj</i>. The number of steps equal completed instructions +
   instructions getting exception + interrupts.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>

    <b>General</b> Thrown if <i>obj</i> is <tt>NULL</tt>.
   </dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>

    number of pc steps, or zero if given a <tt>NULL</tt> pointer.
   </dd>
</dl>
<a name="label855"></a><h6 class="jdocu">SIM_step_next_occurrence()</h6 class="jdocu">

<a name="label856"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label857"></a><b>SIM_step_next_occurrence</b> &#8212; get number of steps until a step queue event occurs</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">pc_step_t 
SIM_step_next_occurrence(conf_object_t *obj, 
                         event_handler_t func,
                         typed_lang_void *user_data);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
SIM_step_next_occurrence finds first event in <i>obj</i>s
   associated step queue that matches <i>func</i> and <i>user_arg.</i>
   If user_arg is <tt>NULL</tt> it will match any
   parameter. Returns steps to occurrence + 1, or zero if there is no
   match.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>General</b> Thrown if <i>obj</i> or
   <i>func</i> is <tt>NULL</tt>.</dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
steps to event + 1, or 0 if no such
   event is in the queue.</dd>
</dl>
<a name="label858"></a><h6 class="jdocu">SIM_step_post()</h6 class="jdocu">

<a name="label859"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label860"></a><b>SIM_step_post</b> &#8212; add an event in step queue</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_step_post(conf_object_t *obj, pc_step_t steps,
              event_handler_t func, lang_void *user_data);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<a name="label861"></a>
   <a name="label862"></a>
   SIM_step_post enqueues an event in the step queue. 
   After <i>steps</i> steps at the processor associated to
   <i>obj</i>, the event will occur, i.e. <i>func</i> will
   be called with <i>obj</i> and <i>user_data</i> as arguments.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>General</b> Thrown if
   <i>obj</i> or <i>func</i> is <tt>NULL</tt>.</dd>
</dl>
<a name="label863"></a><h6 class="jdocu">SIM_time_clean()</h6 class="jdocu">

<a name="label864"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label865"></a><b>SIM_time_clean</b> &#8212; remove all matching events from time queue</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void 
SIM_time_clean(conf_object_t *obj, 
               sync_t sync,
               event_handler_t func,
               typed_lang_void *user_data);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
SIM_time_clean removes all events in <i>obj</i>'s associated time queue
   that matches <i>sync</i>, <i>func</i> and
   <i>user_data</i>.  If <i>user_data</i> is <tt>NULL</tt> it
   will match any parameter, thus removing all installed functions that match
   regardless of the argument to handler.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>

   <b>General</b> Thrown if <i>obj</i> or <i>func</i> is <tt>NULL</tt>.
   </dd>
</dl>
<a name="label866"></a><h6 class="jdocu">SIM_time_next_occurrence()</h6 class="jdocu">

<a name="label867"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label868"></a><b>SIM_time_next_occurrence</b> &#8212; get cycles to matching event</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">cycles_t 
SIM_time_next_occurrence(conf_object_t *obj,
                         event_handler_t func,
                         typed_lang_void *user_data);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
SIM_time_next_occurrence finds first event in the time queue associated to
   <i>obj</i> that matches <i>func</i> and <i>user_data</i>. If the
   <i>user_data</i> argument is <tt>NULL</tt> it will match any
   parameter. Returns time to occurrence + 1, or zero if there is
   no match.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>

   <b>General</b> Thrown if <i>obj</i> or <i>func</i> is <tt>NULL</tt>.
    <br>
   </dd>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
 SIM_time_next_occurrence returns cycles to
   event + 1, 0 if no match.
   </dd>
</dl>
<a name="label869"></a><h6 class="jdocu">SIM_time_post()</h6 class="jdocu">

<a name="label870"></a><a name="label871"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label872"></a><b>SIM_time_post</b><b>, SIM_time_post_cycle</b> &#8212; add event to time queue</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void 
SIM_time_post(conf_object_t *obj,
              double seconds,
              sync_t sync,
              event_handler_t func,
              lang_void *user_data);
</pre><pre class="jdocu_small" style="color: black">void 
SIM_time_post_cycle(conf_object_t *obj,
                    cycles_t cycles,
                    sync_t sync,
                    event_handler_t func,
                    lang_void *user_data);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<a name="label873"></a><a name="label874"></a><b><i>SIM_time_post</i></b> will
   schedule an event that will occur after <i>delta_seconds</i> counted
   from local current time at <i>obj</i>. The time is rounded down to the
   nearest clock cycle, except between zero (inclusive) up to one where it will
   be rounded up to one. At that time <b><i>func()</i></b> will be called with
   <i>obj</i> and <i>user_data</i> as arguments.
<p>
   <a name="label875"></a>
   
<pre class="jdocu_small" style="color: black">typedef enum {
        Sim_Sync_Processor = 0,
        /* Sim_Sync_Node = 1,            not supported yet */
        Sim_Sync_Machine = 2
} sync_t;</pre>

<p>
   If <i>sync</i> is set to <tt>Sim_Sync_Machine</tt>, all other
   objects will have the same local time when the event occurs. This requires
   that the delta is larger than the simulation time quantum if the simulation
   is not currently synchronized. If the delta is smaller than the quantum and
   time is not synchronized, it will be set to the quantum before the event is
   inserted.
<p>
   <b><i>SIM_time_post_cycle</i></b> does the same as <b><i>SIM_time_post</i></b> but
   time is specified as a number of clock cycles, not in seconds. zero cycles
   is not rounded up to one cycle. Note that the clock cycle length is
   typically set in the simics configuration and may differ between processors.
<p>
   <b><i>SIM_time_next_occurrence</i></b> finds first event in the time queue
   associated with <i>obj</i> that matches <i>func</i> and
   <i>user_data.</i> If the <i>user_data</i> argument is <tt>NULL</tt>,
   it will match any parameter. Returns the time to occurrence + 1, or zero if
   there is no match.
<p>
   <b><i>SIM_time_clean</i></b> removes all events in <i>obj</i>s associated time
   queue that matches <i>func</i> and <i>user_data</i>. If user_data is
   <tt>NULL</tt>, it will match any parameter, thus removing all
   functions that match regardless of the argument to func. Note that the older
   version of <b><i>SIM_time_clean()</i></b> without the <i>sync</i>
   parameter is deprecated since Simics 1.6.
<p>
   <b><i>SIM_cycle_count</i></b> returns current simulated clock cycle count at
   <i>obj</i>. Note that if processors are running at different frequency, the
   number will differ between processors, regardless of simulation quantum
   effects.
<p>
   <b><i>SIM_time</i></b> returns current time at <i>obj</i>. Time is counted in
   seconds and has a maximum resolution of a clock cycle.
<p>
   <b><i>SIM_stall_cycle</i></b> set the stall time at <i>obj</i>. <i>cycle</i> is
   the number of clock cycles the processor will stall. A call to this function
   will overwrite the current time left to stall at obj. No compensation is
   made if time differs between obj and where the function is called from.
<p>
   <b><i>SIM_stall</i></b> does the same thing as <b><i>SIM_stall_cycle</i></b> but
   the stall time is given in seconds.
<p>
   <b><i>SIM_stalled_until</i></b> returns how may more cycles the processor will
   stall.
<p>
   <b><i>SIM_stall_count</i></b> returns the total number of cycles the processor
   has been stalled.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>Index</b> Thrown if <i>sync</i> has an
    illegal value.<br>
   <b>General</b> Thrown if <i>obj</i> or <i>func</i> is <tt>NULL</tt>.
    <br>
   <b>General</b> Thrown if <i>seconds</i> violates the minimum time quantum
    for a synchronizing event or if it is negative.</dd>
</dl>

<a name="label876"></a><h5 class="jdocu">User Interface</h5 class="jdocu">
<a name="label877"></a><h6 class="jdocu">SIM_get_batch_mode()</h6 class="jdocu">

<a name="label878"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label879"></a><b>SIM_get_batch_mode</b> &#8212; return setting of the batch-mode</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_get_batch_mode(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function returns the current value of Simics's batch-mode flag.</dd>

<p>
</dl>
<a name="label880"></a><h6 class="jdocu">SIM_is_interactive()</h6 class="jdocu">

<a name="label881"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label882"></a><b>SIM_is_interactive</b> &#8212; running interactive command predicate</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
SIM_is_interactive(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns true if Simics is running commands from the Simics prompt,
  as opposed to running commands from a file via the <tt>-x</tt>
  command line option, the <tt>run-command-file</tt> CLI command, or the
  <b><i>SIM_run_command_file()</i></b> API function.</dd>

<p>
</dl>
<a name="label883"></a><h6 class="jdocu">SIM_post_command()</h6 class="jdocu">

<a name="label884"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label885"></a><b>SIM_post_command</b> &#8212; post callback to be run when simulation is stopped</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_post_command(void (*f)(lang_void *data), lang_void *data);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function posts <b><i>f(<i>data</i>)</i></b> to be called
   from a "stable" state in Simics. This means that Simics will stop
   the simulation, if it is in progress (causing a
   <tt>Core_Simulation_Stopped</tt> hap), finish running any
   event-handlers, hap-handlers, or commands, and then do the call.
<p>
   Note that the simulation will be stopped when <b><i>f</i></b>
   returns, but any call to <b><i>SIM_continue()</i></b> from within
   <b><i>f</i></b> will cause the simulation to restart immediately
   after.
<p>
   <hr class="jdocu_note"><b>Note:</b> This function is deprecated, and may disappear in a future
   release.<hr class="jdocu_note"></dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label790">SIM_continue</a></dl>
<a name="label886"></a><h6 class="jdocu">SIM_quit()</h6 class="jdocu">

<a name="label887"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label888"></a><b>SIM_quit</b> &#8212; quit Simics</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_quit(int exit_code);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Quit Simics in orderly fashion. The Simics process will return
   the value <i>exit_code</i>.</dd>

<p>
</dl>
<a name="label889"></a><h6 class="jdocu">SIM_run_command_file()</h6 class="jdocu">

<a name="label890"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label891"></a><b>SIM_run_command_file</b> &#8212; read CLI commands from file</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_run_command_file(const char *file);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Read and execute the script-file <i>file</i>; i.e., execute each line
   in the file as if it was typed at the Simics prompt.
   <p>
   This function is functionally equivalent to the <i>-x</i> command line
   option.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
run-command-file</dl>
<a name="label892"></a><h6 class="jdocu">SIM_set_prompt()</h6 class="jdocu">

<a name="label893"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label894"></a><b>SIM_set_prompt</b> &#8212; change prompt in Simics</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_set_prompt(const char *new_prompt);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Change the current command-line prompt in Simics.</dd>

<p>
</dl>
<a name="label895"></a><h6 class="jdocu">SIM_source_python()</h6 class="jdocu">

<a name="label896"></a><a name="label897"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label898"></a><b>SIM_source_python</b><b>, SIM_source_python_in_module</b> &#8212; execute Python source file</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
SIM_source_python(const char *file);
</pre><pre class="jdocu_small" style="color: black">void
SIM_source_python_in_module(const char *file, const char *module);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>SIM_source_python()</i></b> will execute a Python source file as
   specified by the file name <i>file</i>. Note that this assumes that
   the Python frontend has been loaded (this is the default frontend in
   Simics). <b><i>SIM_source_python_in_module()</i></b> is similar but imports
   the file in a named Python module.</dd>

<p>
<dt class="jdocu_descitem">EXCEPTIONS</dt><dd>
<b>General</b> Thrown if there was an error
   when executing the Python script.</dd>
</dl>



    <a name="label899"></a><h4 class="jdocu">3.3.3&nbsp;&nbsp;&nbsp;PCI</h4 class="jdocu">

    
<p>
    The PCI Device API is a set of functions that simplifies the
    work of writing PCI devices in Simics. The functions are implemented
    in the file <tt>src/devices/pci-device/pci-device.c</tt>. This
    file has to be included as a source file in modules using the API.
    The <i>Simics User Guide</i> contain descriptions of PCI in Simics,
    and how to write own PCI devices.
<p>
    <a name="label900"></a><h5 class="jdocu">Function List</h5 class="jdocu">
<a name="label901"></a><h6 class="jdocu">PCIE_send_message()</h6 class="jdocu">

<a name="label902"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label903"></a><b>PCIE_send_message</b> &#8212; send a message to root complex</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
PCIE_send_message(pci_device_t *pci, pcie_message_type_t type, 
                  byte_string_t payload);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Send a PCI Express message to the root complex, of a given
   <i>type</i> with a possibly empty <i>payload</i>. This
   function is only available to PCI Express devices.
<p>
   The <tt>pcie_message_type_t</tt> has the following definition:
   
   
<pre class="jdocu_small" style="color: black">typedef enum {
        /* INTx emulation */
        PCIE_Msg_Assert_INTA       = 0x20,
        PCIE_Msg_Assert_INTB       = 0x21,
        PCIE_Msg_Assert_INTC       = 0x22,
        PCIE_Msg_Assert_INTD       = 0x23,
        PCIE_Msg_Deassert_INTA     = 0x24,
        PCIE_Msg_Deassert_INTB     = 0x25,
        PCIE_Msg_Deassert_INTC     = 0x26,
        PCIE_Msg_Deassert_INTD     = 0x27,

        /* Power Management */
        PCIE_PM_Active_State_Nak   = 0x14,
        PCIE_PM_PME                = 0x18,
        PCIE_PM_Turn_Off           = 0x19,
        PCIE_PM_PME_TO_Ack         = 0x1B,

        /* Error Messages */
        PCIE_ERR_COR               = 0x30,
        PCIE_ERR_NONFATAL          = 0x31,
        PCIE_ERR_FATAL             = 0x33,

        /* Locked Transaction */
        PCIE_Locked_Transaction    = 0x00,

        /* Slot Power Limit */
        PCIE_Set_Slot_Power_Limit  = 0x90,

        /* Hot Plug Messages */
        PCIE_HP_Power_Indicator_On        = 0x45,
        PCIE_HP_Power_Indicator_Blink     = 0x47,
        PCIE_HP_Power_Indicator_Off       = 0x44,
        PCIE_HP_Attention_Button_Pressed  = 0x48,
        PCIE_HP_Attention_Indicator_On    = 0x41,
        PCIE_HP_Attention_Indicator_Blink = 0x43,
        PCIE_HP_Attention_Indicator_Off   = 0x40
} pcie_message_type_t;</pre>
</dd>

<p>
</dl>
<a name="label904"></a><h6 class="jdocu">PCI_add_config_register()</h6 class="jdocu">

<a name="label905"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label906"></a><b>PCI_add_config_register</b> &#8212; add device specific configuration register</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
PCI_add_config_register(pci_device_t *pci, uint32 offset,
                        const char *name, int size, uint32 mask,
                        uint32 initial_value);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Adds a device specific configuration register to the generic
   PCI device. When the generic PCI code knows the size of the
   register, it can handle overlapping register accesses. This
   means that the <tt>conf_write_func</tt> function (registered
   with <b><i>PCI_device_init</i></b>) always will be called with an
   offset that is the start of a register. It is not possible to
   override the standard configuration registers using this
   function. The <i>mask</i> argument is the write mask. Only
   bits set in this mask will be writable in the register. Note that
   register names and sizes are not checkpointed and always has to
   be initialized when a device is instantiated. The mask, however,
   is checkpointed since it may be changed at run-time.
<p>
   The newly created config register will contain <i>initial_value</i>.</dd>

<p>
</dl>
<a name="label907"></a><h6 class="jdocu">PCI_bridge_default_access_not_taken()</h6 class="jdocu">

<a name="label908"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label909"></a><b>PCI_bridge_default_access_not_taken</b> &#8212; default handling of unclaimed accesses</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">exception_type_t
PCI_bridge_default_access_not_taken(
        conf_object_t *obj,
        conf_object_t *src_space, conf_object_t *dst_space,
        exception_type_t ex,
        generic_transaction_t *mem_op,
        map_info_t mapinfo);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
If no callback is installed to handle accesses to unmapped addresses
   for type 1 devices, then this function is called. It set the master
   abort flag in the <tt>Secondary Status</tt> register, and return a
   value with all ones. Master abort mode 1, where a target abort on the
   primary bus is signalled instead, is currently not implemented.</dd>

<p>
</dl>
<a name="label910"></a><h6 class="jdocu">PCI_bridge_default_interrupt_lowered()</h6 class="jdocu">

<a name="label911"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label912"></a><b>PCI_bridge_default_interrupt_lowered</b> &#8212; default handling of secondary interrupts</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">static void
PCI_bridge_default_interrupt_lowered(conf_object_t *obj, 
                                     conf_object_t *irq_obj,
                                     int dev, int pin);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Performs the default handling of lowered interrupts on the
   secondary PCI bus that should be routed to the primary bus.
   The interrupt line is changed in the following way:
   <tt>pin = (pin + device) % 4</tt>. It is possible to override
   this function using <b><i>PCI_bridge_init</i></b>.</dd>

<p>
</dl>
<a name="label913"></a><h6 class="jdocu">PCI_bridge_default_interrupt_raised()</h6 class="jdocu">

<a name="label914"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label915"></a><b>PCI_bridge_default_interrupt_raised</b> &#8212; default handling of secondary interrupts</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">static void
PCI_bridge_default_interrupt_raised(conf_object_t *obj, 
                                    conf_object_t *irq_obj,
                                    int dev, int pin);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Performs the default handling of raised interrupts received on
   the secondary PCI bus that should be routed to the primary bus.
   The interrupt line is changed in the following way:
   <tt>pin = (pin + device) % 4</tt>. It is possible to override
   this function using <b><i>PCI_bridge_init</i></b>.</dd>

<p>
</dl>
<a name="label916"></a><h6 class="jdocu">PCI_bridge_default_system_error()</h6 class="jdocu">

<a name="label917"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label918"></a><b>PCI_bridge_default_system_error</b> &#8212; default system error handling for bridges</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
PCI_bridge_default_system_error(conf_object_t *obj);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
If no callback is installed to handle system errors for type 1 devices,
   then this function is called. It will set the system error received bit
   in the <tt>Secondary Status</tt> register, and signal system error on
   the primary bus.</dd>

<p>
</dl>
<a name="label919"></a><h6 class="jdocu">PCI_bridge_init()</h6 class="jdocu">

<a name="label920"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label921"></a><b>PCI_bridge_init</b> &#8212; Initialize generic PCI bridge device</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
PCI_bridge_init(pci_device_t *pci,
                void (*system_error)(conf_object_t *obj),
                exception_type_t (*access_not_taken)(
                        conf_object_t *obj,
                        conf_object_t *src_space,
                        conf_object_t *dst_space,
                        exception_type_t ex,
                        generic_transaction_t *mem_op,
                        map_info_t mapinfo),
                void (*interrupt_raised)(
                        conf_object_t *obj, 
                        conf_object_t *dev_obj,
                        int device, int pin),
                void (*interrupt_lowered)(
                        conf_object_t *obj, 
                        conf_object_t *dev_obj,
                        int device, int pin),
                int forward_io, int forward_io32,
                int forward_mem,
                int forward_prefetchable, 
                int forward_prefetchable64);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Initializes a generic PCI-to-PCI (type 1) device. This function should
   be called directly after <b><i>PCI_device_init</i></b>. The <i>system_error</i>
   callback can be set to receive system errors on the secondary bus. If none
   is given, the <b><i>PCI_bridge_default_system_error</i></b> function is used as
   default. Similarly for the <i>access_not_taken</i> argument, that defaults
   to <b><i>PCI_bridge_default_access_not_taken</i></b>. The <i>interrupt_raised</i>
   and <i>interrupt_lowered</i> functions can be used to override
   <b><i>PCI_bridge_default_interrupt_raised</i></b> and
   <b><i>PCI_bridge_default_interrupt_lowered</i></b>. The next arguments specify what
   kind of transactions that the bridge supports. 16-bit I/O, 32-bit I/O operations,
   memory, prefetchable memory and 64-bit prefetchable memory operations.</dd>

<p>
</dl>
<a name="label922"></a><h6 class="jdocu">PCI_bridge_map_setup()</h6 class="jdocu">

<a name="label923"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label924"></a><b>PCI_bridge_map_setup</b> &#8212; Set optional memory mapping attributes</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
PCI_bridge_map_setup(
        pci_device_t *pci,
        int io_down_priority, int io_down_align_size, int io_down_endian,
        int mem_down_priority, int mem_down_align_size, int mem_down_endian,
        int pref_down_priority, int pref_down_align_size, int pref_down_endian,
        int io_up_priority, int io_up_align_size, int io_up_endian,
        int mem_up_priority, int mem_up_align_size, int mem_up_endian);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Configures the bridge's memory mappings. The priority,
   align_size boundary and a reverse-endian flag can be set for
   each mapping. These values are described in the <tt>map</tt>
   attribute of the <tt>memory-space</tt> class. Default is 0
   for all values. The mappings that can be modified are IO
   downstream, memory downstream, prefetchable memory downstream,
   IO upstream and memory upstream.</dd>

<p>
</dl>
<a name="label925"></a><h6 class="jdocu">PCI_config_register_name()</h6 class="jdocu">

<a name="label926"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label927"></a><b>PCI_config_register_name</b> &#8212; return name of a configuration register</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">const char *
PCI_config_register_name(pci_device_t *pci, uint32 offset);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the name of a configuration register, specified by a
   byte offset into the configuration header. Only standard configuration
   registers, i.e. as defined in the PCI specification, are handled.
   The header type of the PCI device affects the result.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>

   The name of the configuration register is returned if the offset
   corresponds to a valid configuration register. If not, NULL is
   returned.
   </dd>
</dl>
<a name="label928"></a><h6 class="jdocu">PCI_config_register_size()</h6 class="jdocu">

<a name="label929"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label930"></a><b>PCI_config_register_size</b> &#8212; return size of a configuration register</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">uint32
PCI_config_register_size(pci_device_t *pci, uint32 offset);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the size of a configuration register, specified by a
   byte offset into the configuration header. Only standard configuration
   registers, i.e. as defined in the PCI specification, are handled.
   The header type of the PCI device affects the result.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>

   The size (in bytes) of the configuration register is returned if the
   offset corresponds to a valid configuration register. If not, 0 is
   returned.
   </dd>
</dl>
<a name="label931"></a><h6 class="jdocu">PCI_configuration_access()</h6 class="jdocu">

<a name="label932"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label933"></a><b>PCI_configuration_access</b> &#8212; access the configuration space</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">exception_type_t
PCI_configuration_access(pci_device_t *pci, 
                         generic_transaction_t *mop);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>PCI_configuration_access</i></b> function performs an access
   to the configuration header registers. It handles overlapping accesses
   and both reads and writes. This function is typically only needed for
   PCI device that map the configuration space in the I/O and/or memory
   space mappings. The PCI device can then call this function. Accesses
   using the configuration space it handled by the generic PCI device
   itself (by calling this function).</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>

   The returned value is always <tt>Sim_PE_No_Exception</tt>.
   </dd>
</dl>
<a name="label934"></a><h6 class="jdocu">PCI_data_from_memory()</h6 class="jdocu">

<a name="label935"></a><a name="label936"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label937"></a><b>PCI_data_from_memory</b><b>, PCI_data_to_memory</b> &#8212; read/write raw data from memory space</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">exception_type_t
PCI_data_from_memory(pci_device_t *pci, addr_space_t space,
                     uint8 *buffer, uint64 address, uint64 size);
</pre><pre class="jdocu_small" style="color: black">exception_type_t
PCI_data_to_memory(pci_device_t *pci, addr_space_t space,
                   uint8 *buffer, uint64 address, uint64 size);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>PCI_data_from_memory</i></b> reads data from a memory-space
   specified by <i>space</i>, and places it in a buffer
   pointed to by <i>buffer</i>. No endian conversion is
   performed. <b><i>PCI_data_to_memory</i></b> writes data to the
   memory space.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>

   The pseudo exception from the memory-space is returned.
   </dd>
</dl>
<a name="label938"></a><h6 class="jdocu">PCI_default_configuration_read_access()</h6 class="jdocu">

<a name="label939"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label940"></a><b>PCI_default_configuration_read_access</b> &#8212; default function for configuration register reads</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">uint32
PCI_default_configuration_read_access(conf_object_t *obj, 
                                      uint32 offset, uint32 size);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
A PCI device can override this default configuration read function
   with a function specified in the <b><i>PCI_device_init</i></b> call.
   The overriding function can then call this default function for
   configuration registers that it does not handle itself.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>

   The value of the configuration register is returned.
   </dd>
</dl>
<a name="label941"></a><h6 class="jdocu">PCI_default_configuration_write_access()</h6 class="jdocu">

<a name="label942"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label943"></a><b>PCI_default_configuration_write_access</b> &#8212; default function for configuration register writes</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
PCI_default_configuration_write_access(conf_object_t *obj, 
                                       uint32 offset, uint32 size, 
                                       uint32 value);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
A PCI device can override this default configuration wite function
   with a function specified in the <b><i>PCI_device_init</i></b> call.
   The overriding function can then call this default function for
   configuration registers that it does not handle itself. Side-effects
   for the <tt>Command</tt>, <tt>Status</tt>, <tt>Base Address</tt>,
   <tt>Secondary Status</tt> and <tt>Expansion ROM Base</tt>
   registers are handled.</dd>

<p>
</dl>
<a name="label944"></a><h6 class="jdocu">PCI_default_device_reset()</h6 class="jdocu">

<a name="label945"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label946"></a><b>PCI_default_device_reset</b> &#8212; default PCI device reset handling</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
PCI_default_device_reset(conf_object_t *obj);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
A PCI device can override this default reset function with a
   function specified in the <b><i>PCI_device_init</i></b> call.
   The overriding function can then call this default function to
   get the default behavior as well.  All memory mappings are
   disabled, and the following registers are cleared: <tt>Command</tt>,
   <tt>Status</tt>, <tt>Cache Line Size</tt>, <tt>Latency Timer</tt>,
   <tt>BIST</tt>, <tt>Interrupt Line</tt> and all base address registers.</dd>

<p>
</dl>
<a name="label947"></a><h6 class="jdocu">PCI_device_init()</h6 class="jdocu">

<a name="label948"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label949"></a><b>PCI_device_init</b> &#8212; initialize the generic PCI device</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
PCI_device_init(log_object_t *log, int log_group,
                pci_device_t *pci,
                pci_device_t *(*unused)(conf_object_t *), /* call with NULL */
                void (*pci_bus_reset)(conf_object_t *obj),
                uint32 (*conf_read_func)(conf_object_t *obj, 
                                         uint32 offset, 
                                         uint32 size),
                void (*conf_write_func)(conf_object_t *obj, 
                                        uint32 offset, 
                                        uint32 size, 
                                        uint32 value),
                exception_type_t (*pci_operation)(
                        conf_object_t *obj,
                        generic_transaction_t *mem_op,
                        map_info_t map_info));
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Initializes the generic PCI device and optionally overrides some default
   functions. The arguments <i>log</i> and <i>pci</i> are pointers
   within the device structure, and <i>log_group</i> is the log group
   (as defined by <b><i>SIM_log_register_groups</i></b>) that the generic PCI
   device should use for configuration related logging. Use 0 if no log groups
   are defined. The <i>unused</i> function should be NULL.
   PCI bus resets are delivered to each PCI device by calling the
   installed <i>pci_bus_reset</i> function.
   The <i>conf_read_func</i> and <i>conf_write_func</i> functions
   are optional, they can be used to override the default behavior on
   accesses to the device's configuration registers. When called, the
   <i>offset</i> and <i>size</i> arguments corresponds to a complete
   configuration register if it is known. It is therefore recommended that
   device specific registers are added with <b><i>PCI_add_config_register</i></b>.
   I.e. partial and overlapping accesses are handled by the generic PCI device
   code before these callbacks are called. Accesses that do not correspond
   to known registers are handled byte by byte.
   The <i>pci_irq_ack</i> function is also optional, it is only used if
   the device responds to <i>Interrupt Acknowledge</i> cycles on the PCI bus.
   The last argument, <i>pci_operation</i>, is required. This function is
   called for all accesses to the memory and I/O mappings of the device. Memory
   and I/O space mappings can be created with <b><i>PCI_handle_mapping32</i></b>
   and <b><i>PCI_handle_mapping64</i></b>.
<p>
   The generic PCI device code will use the <tt>object_data</tt> field of the
   conf_object_t struct, it should not be modified by the code implementing
   a specific device.</dd>

<p>
</dl>
<a name="label950"></a><h6 class="jdocu">PCI_get_bus_address()</h6 class="jdocu">

<a name="label951"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label952"></a><b>PCI_get_bus_address</b> &#8212; get the bus address of a device</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">int
PCI_get_bus_address(pci_device_t *pci);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the PCI bus address for the device.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>

   The PCI bus address, in PCI Type 1 address format. I.e.
   <tt>bus &lt;&lt; 16 | device &lt;&lt; 11 | function &lt;&lt; 8</tt>.
   On error, if the device isn't found on the bus, -1 is returned.
   </dd>
</dl>
<a name="label953"></a><h6 class="jdocu">PCI_get_config_register_mask()</h6 class="jdocu">

<a name="label954"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label955"></a><b>PCI_get_config_register_mask</b> &#8212; get write mask of a configuration register</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">uint32
PCI_get_config_register_mask(pci_device_t *pci, uint32 offset);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the write mask for a configuration register.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>

   Configuration register write mask.
   </dd>
</dl>
<a name="label956"></a><h6 class="jdocu">PCI_handle_mapping32()</h6 class="jdocu">

<a name="label957"></a><a name="label958"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label959"></a><b>PCI_handle_mapping32</b><b>, PCI_handle_mapping64</b> &#8212; handle base address register</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
PCI_handle_mapping32(pci_device_t *pci, int reg,
                     addr_space_t space,
                     uint32 size, int function, int priority,
                     uint64 target_offset,
                     conf_object_t *target,
                     int alignment, int inverse_endian);
</pre><pre class="jdocu_small" style="color: black">void
PCI_handle_mapping64(pci_device_t *pci, int reg,
                     uint64 size, int function, int priority,
                     uint64 target_offset,
                     conf_object_t *target,
                     int alignment, int inverse_endian);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Tells the generic PCI device code to handle the memory mapping associated
   with the base address at configuration header offset <i>reg</i>. All
   read and write accesses to the base address will be handled, and the
   mappings will be enabled and disabled according to the enable bits in the
   PCI <tt>command</tt> register, and for expansion ROM also the enable bit
   in the base address register itself. The lowest bits in the base address
   register will be set to indicate space type and if the device is 32 or
   64 bit addressable. 64 bit mappings are registered with
   <b><i>PCI_handle_mapping64</i></b>, and 32 bit ones with
   <b><i>PCI_handle_mapping32</i></b>.
<p>
   The <i>space</i> argument specifies if the memory or I/O space is used.
   The <i>size</i> argument is the size of the memory mappings,  and
   <i>function</i> a function number used to identify the mapping. The
   <i>priority</i> should be 0, unless the device can have mappings that
   overlap, in that case each mapping must have unique priority. By default
   the device itself is mapped at the base address, but in some cases another
   object should be the target. In that case, the <i>target</i> argument
   can be set, and <i>target_offset</i> to the byte offset into the target.
   It is also possible to set an alignment boundary size, and an inverse
   endian flags. These are documented with the <tt>map</tt> attribute in the
   <tt>memory-space</tt> class.
<p>
   There are also functions in the PCI Device API that can be used to
   modify the mapping in run-time. This is not needed for standard PCI
   devices.</dd>

<p>
</dl>
<a name="label960"></a><h6 class="jdocu">PCI_raise_interrupt()</h6 class="jdocu">

<a name="label961"></a><a name="label962"></a><a name="label963"></a><a name="label964"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label965"></a><b>PCI_raise_interrupt</b><b>, PCI_lower_interrupt</b><b>, PCI_raise_interrupt_pin</b><b>, PCI_lower_interrupt_pin</b> &#8212; raise and lower a PCI interrupt</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
PCI_raise_interrupt(pci_device_t *pci);
</pre><pre class="jdocu_small" style="color: black">void
PCI_lower_interrupt(pci_device_t *pci);
</pre><pre class="jdocu_small" style="color: black">void
PCI_raise_interrupt_pin(pci_device_t *pci, int pin);
</pre><pre class="jdocu_small" style="color: black">void
PCI_lower_interrupt_pin(pci_device_t *pci, int pin);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>PCI_raise_interrupt</i></b> raises an interrupt on the pin defined
   by the <tt>PCI_INTERRUPT_PIN</tt> configuration register. If an interrupt
   is already asserted, the call has no effect. Similarly for
   <b><i>PCI_lower_interrupt</i></b> that lowers the interrupt level if it already
   is raised. The <b><i>PCI_raise_interrupt_pin</i></b> and <b><i>PCI_lower_interrupt_pin</i></b>
   functions take an extra argument that is the interrupt pin. These two functions
   should not be used by most PCI devices, but bridges may need them.</dd>

<p>
<dt class="jdocu_descitem">NOTE</dt><dd>

   A raise triggers an interrupt, and refers to the logical signal. It does
   not reflect the actual physical signal level on the PCI bus where
   interrupt lines are active low.
   </dd>
</dl>
<a name="label966"></a><h6 class="jdocu">PCI_read_sized_config_register()</h6 class="jdocu">

<a name="label967"></a><a name="label968"></a><a name="label969"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label970"></a><b>PCI_read_sized_config_register</b><b>, PCI_read_config_register</b><b>, PCI_write_config_register</b> &#8212; read a configuration register</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">uint32
PCI_read_sized_config_register(pci_device_t *pci, uint32 offset, 
                               uint32 size);
</pre><pre class="jdocu_small" style="color: black">uint32
PCI_read_config_register(pci_device_t *pci, uint32 offset);
</pre><pre class="jdocu_small" style="color: black">void
PCI_write_config_register(pci_device_t *pci, uint32 offset, 
                          uint32 value);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Returns the value of a configuration register specified by a byte
   offset into the configuration header. The <b><i>PCI_read_config_register</i></b>
   function can only be used to read standard configuration registers, i.e. as
   defined in the PCI specification, and registers that are added with
   <b><i>PCI_add_config_register</i></b>. For other configuration registers
   the <b><i>PCI_read_sized_config_register</i></b> should be used, since the sizes
   of those registers are not known to the generic PCI device.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>

   The value, in host endian order, of the configuration register.
   </dd>
</dl>
<a name="label971"></a><h6 class="jdocu">PCI_register_bridge_attributes()</h6 class="jdocu">

<a name="label972"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label973"></a><b>PCI_register_bridge_attributes</b> &#8212; register generic PCI bridge attributes</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
PCI_register_bridge_attributes(conf_class_t *pci_class);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Registers the generic PCI bridge device attributes, and performs
   some early initialization. This function should be called directly
   after <b><i>PCI_register_device_attributes</i></b>.</dd>

<p>
</dl>
<a name="label974"></a><h6 class="jdocu">PCI_register_device_attributes()</h6 class="jdocu">

<a name="label975"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label976"></a><b>PCI_register_device_attributes</b> &#8212; register generic PCI device attributes</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
PCI_register_device_attributes(
        conf_class_t *pci_class,
        int (*interrupt_ack)(conf_object_t *obj),
        void (*special_cycle)(conf_object_t *obj, uint32 value),
        void (*system_error)(conf_object_t *obj),
        void (*interrupt_raised)(conf_object_t *obj, int pin),
        void (*interrupt_lowered)(conf_object_t *obj, int pin));
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Registers the generic PCI device attributes, and performs some
   early initialization. The <b><i>PCI_register_device_attributes</i></b>
   function should be called as early as possible, typically from the
   module's <b><i>init_local</i></b> function. The first argument is the
   configuration class for the PCI device. The following arguments are
   optional functions with callbacks for events on the PCI bus. They
   should only be supplied by devices that respond to Interrupt
   Acknowledge Cycles, listens to Special Cycle data, listens to the
   system error line (SERR#), or receives peer-to-peer interrupts.</dd>

<p>
</dl>
<a name="label977"></a><h6 class="jdocu">PCI_set_config_register_mask()</h6 class="jdocu">

<a name="label978"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label979"></a><b>PCI_set_config_register_mask</b> &#8212; set write mask of a configuration register</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
PCI_set_config_register_mask(pci_device_t *pci, uint32 offset, uint32 mask);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function sets the write mask of a configuration register.
   Only bits set to 1 in <i>mask</i> are writable. Many PCI devices
   do not implement all bits in their configuration registers. By
   setting a write mask for such registers, the default access handling
   in the generic PCI device code can still be used.</dd>

<p>
</dl>
<a name="label980"></a><h6 class="jdocu">PCI_set_map_base()</h6 class="jdocu">

<a name="label981"></a><a name="label982"></a><a name="label983"></a><a name="label984"></a><a name="label985"></a><a name="label986"></a><a name="label987"></a><a name="label988"></a><a name="label989"></a><a name="label990"></a><a name="label991"></a><a name="label992"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label993"></a><b>PCI_set_map_base</b><b>, PCI_get_map_base</b><b>, PCI_set_map_size</b><b>, PCI_get_map_size</b><b>, PCI_set_map_enable</b><b>, PCI_get_map_enable</b><b>, PCI_set_map_offset</b><b>, PCI_get_map_offset</b><b>, PCI_set_map_ignore_command</b><b>, PCI_get_map_ignore_command</b><b>, PCI_set_map_always_on</b><b>, PCI_get_map_always_on</b> &#8212; query and modify base address mapping</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
PCI_set_map_base(pci_device_t *pci, int reg, uint64 base);
</pre><pre class="jdocu_small" style="color: black">uint64
PCI_get_map_base(pci_device_t *pci, int reg);
</pre><pre class="jdocu_small" style="color: black">void
PCI_set_map_size(pci_device_t *pci, int reg, uint64 size);
</pre><pre class="jdocu_small" style="color: black">uint64
PCI_get_map_size(pci_device_t *pci, int reg);
</pre><pre class="jdocu_small" style="color: black">void
PCI_set_map_enable(pci_device_t *pci, int reg, int enable);
</pre><pre class="jdocu_small" style="color: black">int
PCI_get_map_enable(pci_device_t *pci, int reg);
</pre><pre class="jdocu_small" style="color: black">void
PCI_set_map_offset(pci_device_t *pci, int reg, uint64 target_offset);
</pre><pre class="jdocu_small" style="color: black">uint64
PCI_get_map_offset(pci_device_t *pci, int reg);
</pre><pre class="jdocu_small" style="color: black">void
PCI_set_map_ignore_command(pci_device_t *pci, int reg, int map_ignore_command);
</pre><pre class="jdocu_small" style="color: black">int
PCI_get_map_ignore_command(pci_device_t *pci, int reg);
</pre><pre class="jdocu_small" style="color: black">void
PCI_set_map_always_on(pci_device_t *pci, int reg, int always_on);
</pre><pre class="jdocu_small" style="color: black">int
PCI_get_map_always_on(pci_device_t *pci, int reg);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The following functions can be used to modify base address mappings
   that have been registered with <b><i>PCI_handle_mapping32</i></b> and
   <b><i>PCI_handle_mapping64</i></b>. Standard PCI devices typically
   doesn't have to modify the mappings, but some bridges and special
   devices have alternative registers to modify the memory mappings.
   <b><i>PCI_set_map_base</i></b> changes the base address, and also
   the contents of the base address register. <b><i>PCI_set_map_size</i></b>
   changes the size of the memory mapping. The size should be changed
   with care, since it may create an non-sized aligned mapping. The
   <b><i>PCI_set_map_enable</i></b> function can be used to enable and
   disable a mapping, this enable is in addition to the standard
   PCI enable/disable. Finally the <b><i>PCI_set_map_offset</i></b> changes
   the target offset of the mapping. The <tt>_get_</tt> functions can
   be used to query the current state of a mapping.</dd>

<p>
</dl>
<a name="label994"></a><h6 class="jdocu">PCI_set_may_stall()</h6 class="jdocu">

<a name="label995"></a><a name="label996"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label997"></a><b>PCI_set_may_stall</b><b>, PCI_get_may_stall</b> &#8212; Specifies if memory accesses are stallable</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
PCI_set_may_stall(pci_device_t *pci, int may_stall);
</pre><pre class="jdocu_small" style="color: black">int
PCI_get_may_stall(pci_device_t *pci);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <b><i>PCI_set_may_stall</i></b> function can be used to
   enable and disable stallable memory accesses. By default all
   accesses initiated by the device are not stallable.
   <b><i>PCI_get_may_stall</i></b> is used to query if stallable
   accesses are enabled or not.</dd>

<p>
</dl>
<a name="label998"></a><h6 class="jdocu">PCI_system_error()</h6 class="jdocu">

<a name="label999"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1000"></a><b>PCI_system_error</b> &#8212; assert system error</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
PCI_system_error(pci_device_t *pci);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Triggers a system error on the PCI bus, i.e asserts the SERR# line.
   System Errors are used for asynchronous signalling of unrecoverable
   errors, and are usually handled by the host-to-PCI bridge.</dd>

<p>
</dl>
<a name="label1001"></a><h6 class="jdocu">PCI_value_from_memory()</h6 class="jdocu">

<a name="label1002"></a><a name="label1003"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1004"></a><b>PCI_value_from_memory</b><b>, PCI_value_to_memory</b> &#8212; read/write value from memory space</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">uint64
PCI_value_from_memory(pci_device_t *pci, addr_space_t space,
                      exception_type_t *ex,
                      uint64 address, uint32 size);
</pre><pre class="jdocu_small" style="color: black">exception_type_t
PCI_value_to_memory(pci_device_t *pci, addr_space_t space,
                      uint64 value,
                      uint64 address, uint32 size);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>PCI_value_from_memory</i></b> reads data from a memory-space
   specified by <i>space</i>, and returns it in the endian
   byte-order of the host, i.e. as a value. <b><i>PCI_value_to_memory</i></b>
   writes <i>value</i> to the memory space.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>

   The pseudo exception from the memory-space is returned.
   </dd>
</dl>
<a name="label1005"></a><h6 class="jdocu">PCI_write_sized_config_register()</h6 class="jdocu">

<a name="label1006"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1007"></a><b>PCI_write_sized_config_register</b> &#8212; write a configuration register</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
PCI_write_sized_config_register(pci_device_t *pci, uint32 offset, 
                                uint32 value, uint32 size);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Writes a value, in host endian order, to a configuration register
   specified by a byte offset into the configuration header. The
   <b><i>PCI_write_config_register</i></b> function can only be used to
   write standard configuration registers, i.e. as defined in the PCI
   specification. <b><i>PCI_write_sized_config_register</i></b> is
   typically used to write device specific configuration registers
   since the sizes of those registers are not known to the generic PCI
   device.</dd>

<p>
<dt class="jdocu_descitem">NOTE</dt><dd>

   No side effects are triggered by writing configuration registers with
   these functions. <b><i>PCI_default_configuration_write_access</i></b>
   can be used to get the side effects handled by the generic PCI device.
   </dd>
</dl>


    <a name="label1008"></a><h4 class="jdocu">3.3.4&nbsp;&nbsp;&nbsp;Micro-Architecture Interface</h4 class="jdocu">

    
<p>
    The Micro-Architecture Interface is described in the <em>Simics MAI
    Guide</em>.
<p>
    <a name="label1009"></a><h5 class="jdocu">Function List</h5 class="jdocu">
<a name="label1010"></a><h6 class="jdocu">SIM_instruction_begin()</h6 class="jdocu">

<a name="label1011"></a><a name="label1012"></a><a name="label1013"></a><a name="label1014"></a><a name="label1015"></a><a name="label1016"></a><a name="label1017"></a><a name="label1018"></a><a name="label1019"></a><a name="label1020"></a><a name="label1021"></a><a name="label1022"></a><a name="label1023"></a><a name="label1024"></a><a name="label1025"></a><a name="label1026"></a><a name="label1027"></a><a name="label1028"></a><a name="label1029"></a><a name="label1030"></a><a name="label1031"></a><a name="label1032"></a><a name="label1033"></a><a name="label1034"></a><a name="label1035"></a><a name="label1036"></a><a name="label1037"></a><a name="label1038"></a><a name="label1039"></a><a name="label1040"></a><a name="label1041"></a><a name="label1042"></a><a name="label1043"></a><a name="label1044"></a><a name="label1045"></a><a name="label1046"></a><a name="label1047"></a><a name="label1048"></a><a name="label1049"></a><a name="label1050"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1051"></a><b>SIM_instruction_begin</b><b>, SIM_instruction_end</b><b>, SIM_instruction_insert</b><b>, SIM_instruction_child</b><b>, SIM_instruction_parent</b><b>, SIM_instruction_cpu</b><b>, SIM_instruction_proceed</b><b>, SIM_instruction_fetch</b><b>, SIM_instruction_decode</b><b>, SIM_instruction_execute</b><b>, SIM_instruction_retire</b><b>, SIM_instruction_commit</b><b>, SIM_instruction_squash</b><b>, SIM_instruction_rewind</b><b>, SIM_instruction_handle_exception</b><b>, SIM_instruction_handle_interrupt</b><b>, SIM_instruction_nth_id</b><b>, SIM_instruction_set_stop_phase</b><b>, SIM_instruction_phase</b><b>, SIM_instruction_speculative</b><b>, SIM_instruction_force_correct</b><b>, SIM_instruction_type</b><b>, SIM_instruction_length</b><b>, SIM_instruction_status</b><b>, SIM_instruction_get_reg_info</b><b>, SIM_instruction_read_input_reg</b><b>, SIM_instruction_read_output_reg</b><b>, SIM_instruction_write_input_reg</b><b>, SIM_instruction_write_output_reg</b><b>, SIM_instruction_is_sync</b><b>, SIM_instruction_get_user_data</b><b>, SIM_instruction_set_user_data</b><b>, SIM_instruction_id_from_mem_op_id</b><b>, SIM_instruction_stalling_mem_op</b><b>, SIM_instruction_store_queue_mem_op</b><b>, SIM_instruction_remaining_stall_time</b><b>, SIM_instruction_get_field_value</b><b>, SIM_instruction_opcode</b><b>, SIM_release_stall</b><b>, SIM_get_unique_memory_transaction_id</b> &#8212; Micro-Architecture Interface functions</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">instruction_id_t
SIM_instruction_begin(conf_object_t *obj);
</pre><pre class="jdocu_small" style="color: black">instruction_error_t
SIM_instruction_end(instruction_id_t ii);
</pre><pre class="jdocu_small" style="color: black">void
SIM_instruction_insert(instruction_id_t parent_ii,
                       instruction_id_t ii);
</pre><pre class="jdocu_small" style="color: black">instruction_id_t
SIM_instruction_child(instruction_id_t ii, int n);
</pre><pre class="jdocu_small" style="color: black">instruction_id_t
SIM_instruction_parent(instruction_id_t ii);
</pre><pre class="jdocu_small" style="color: black">conf_object_t *
SIM_instruction_cpu(instruction_id_t ii)
/*   */
instruction_error_t
SIM_instruction_proceed(instruction_id_t ii);
</pre><pre class="jdocu_small" style="color: black">instruction_error_t
SIM_instruction_proceed(instruction_id_t ii);
</pre><pre class="jdocu_small" style="color: black">instruction_error_t
SIM_instruction_fetch(instruction_id_t ii);
</pre><pre class="jdocu_small" style="color: black">instruction_error_t
SIM_instruction_decode(instruction_id_t ii);
</pre><pre class="jdocu_small" style="color: black">instruction_error_t
SIM_instruction_execute(instruction_id_t ii);
</pre><pre class="jdocu_small" style="color: black">instruction_error_t
SIM_instruction_retire(instruction_id_t ii);
</pre><pre class="jdocu_small" style="color: black">instruction_error_t
SIM_instruction_commit(instruction_id_t ii);
</pre><pre class="jdocu_small" style="color: black">instruction_error_t
SIM_instruction_squash(instruction_id_t ii);
</pre><pre class="jdocu_small" style="color: black">instruction_error_t 
SIM_instruction_rewind(instruction_id_t ii, instruction_phase_t phase)
/*   */
instruction_error_t
SIM_instruction_handle_exception(instruction_id_t ii);
</pre><pre class="jdocu_small" style="color: black">instruction_error_t
SIM_instruction_handle_exception(instruction_id_t ii);
</pre><pre class="jdocu_small" style="color: black">instruction_error_t
SIM_instruction_handle_interrupt(conf_object_t *cpu,
                                 exception_type_t vector);
</pre><pre class="jdocu_small" style="color: black">instruction_id_t
SIM_instruction_nth_id(int n);
</pre><pre class="jdocu_small" style="color: black">void
SIM_instruction_set_stop_phase(conf_object_t *obj,
                               instruction_phase_t phase,
                               int on);
</pre><pre class="jdocu_small" style="color: black">instruction_phase_t
SIM_instruction_phase(instruction_id_t ii);
</pre><pre class="jdocu_small" style="color: black">int
SIM_instruction_speculative(instruction_id_t ii);
</pre><pre class="jdocu_small" style="color: black">void
SIM_instruction_force_correct(instruction_id_t ii);
</pre><pre class="jdocu_small" style="color: black">instr_type_t
SIM_instruction_type(instruction_id_t ii);
</pre><pre class="jdocu_small" style="color: black">int
SIM_instruction_length(instruction_id_t ii);
</pre><pre class="jdocu_small" style="color: black">instruction_status_t
SIM_instruction_status(instruction_id_t ii);
</pre><pre class="jdocu_small" style="color: black">reg_info_t *
SIM_instruction_get_reg_info(instruction_id_t ii,
                             int n);
</pre><pre class="jdocu_small" style="color: black">attr_value_t
SIM_instruction_read_input_reg(instruction_id_t ii,
                               register_id_t ri);
</pre><pre class="jdocu_small" style="color: black">attr_value_t
SIM_instruction_read_output_reg(instruction_id_t ii,
                                register_id_t ri);
</pre><pre class="jdocu_small" style="color: black">void
SIM_instruction_write_input_reg(instruction_id_t ii,
                                register_id_t ri,
                                attr_value_t value);
</pre><pre class="jdocu_small" style="color: black">instruction_error_t
SIM_instruction_write_output_reg(instruction_id_t ii, 
                                 register_id_t ri,
                                 attr_value_t val);
</pre><pre class="jdocu_small" style="color: black">int
SIM_instruction_is_sync(instruction_id_t ii);
</pre><pre class="jdocu_small" style="color: black">lang_void *
SIM_instruction_get_user_data(instruction_id_t ii);
</pre><pre class="jdocu_small" style="color: black">void
SIM_instruction_set_user_data(instruction_id_t ii,
                              lang_void *);
</pre><pre class="jdocu_small" style="color: black">instruction_id_t
SIM_instruction_id_from_mem_op_id(conf_object_t *cpu, int id);
</pre><pre class="jdocu_small" style="color: black">generic_transaction_t *
SIM_instruction_stalling_mem_op(conf_object_t *obj,
                                instruction_id_t entry);
</pre><pre class="jdocu_small" style="color: black">generic_transaction_t *
SIM_instruction_store_queue_mem_op(instruction_id_t ii, int i);
</pre><pre class="jdocu_small" style="color: black">cycles_t
SIM_instruction_remaining_stall_time(conf_object_t *obj,
                                     instruction_id_t ii);
</pre><pre class="jdocu_small" style="color: black">integer_t
SIM_instruction_get_field_value(instruction_id_t ii,
                                const char *field_name);
</pre><pre class="jdocu_small" style="color: black">attr_value_t
SIM_instruction_opcode(instruction_id_t ii);
</pre><pre class="jdocu_small" style="color: black">void
SIM_release_stall(conf_object_t *obj, int id);
</pre><pre class="jdocu_small" style="color: black">int
SIM_get_unique_memory_transaction_id(conf_object_t *obj);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions constitute the Simics Micro-Architecture Interface,
   and are only available in the Micro-Architecture versions of
   Simics. If you have this version of Simics, you can find the
   documentation of these functions in the <em>Simics Out of Order
   Processor Models</em> document.</dd>

<p>
</dl>


    <a name="label1052"></a><h4 class="jdocu">3.3.5&nbsp;&nbsp;&nbsp;DBuffer Interface</h4 class="jdocu">

    
<p>
    The DBuffer library is part of the Simics API.  It is used to
    efficiently transfer data blocks, such as network packets, inside
    the simulation.  See the <em>Simics Programming Guide</em> for
    an introduction to programming with DBuffers.
<p>
    <a name="label1053"></a><h5 class="jdocu">Function List</h5 class="jdocu">
<a name="label1054"></a><h6 class="jdocu">dbuffer_append()</h6 class="jdocu">

<a name="label1055"></a><a name="label1056"></a><a name="label1057"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1058"></a><b>dbuffer_append</b><b>, dbuffer_prepend</b><b>, dbuffer_insert</b> &#8212; Add data to a dbuffer</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">uint8 *
dbuffer_append(dbuffer_t *dbuffer, size_t len);
</pre><pre class="jdocu_small" style="color: black">uint8 *
dbuffer_prepend(dbuffer_t *dbuffer, size_t len);
</pre><pre class="jdocu_small" style="color: black">uint8 *
dbuffer_insert(dbuffer_t *dbuffer, size_t offset, size_t len);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions will extend the dbuffer with <i>len</i>
   bytes and return a pointer to the added bytes.  The
   <b><i>dbuffer_insert</i></b> function adds the new data at
   <i>offset</i> in the buffer, while the
   <b><i>dbuffer_prepend</i></b> and <b><i>dbuffer_append</i></b> functions
   add it at the the beginning and end, respectively.
<p>
   The returned pointer points to a memory area that is only
   guaranteed to contain valid data for the newly added bytes, and it
   is illegal to reference data before it or more than
   <i>len</i>-1 bytes ahead.
<p>
   The returned pointer is also only valid until the next operation on
   the dbuffer function, except for calling <b><i>dbuffer_len</i></b>.</dd>

<p>
</dl>
<a name="label1059"></a><h6 class="jdocu">dbuffer_append_external_data()</h6 class="jdocu">

<a name="label1060"></a><a name="label1061"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1062"></a><b>dbuffer_append_external_data</b><b>, dbuffer_prepend_external_data</b> &#8212; Add static data</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">uint8 *
dbuffer_append_external_data(dbuffer_t *dbuffer, void *data,
                             size_t len, int adopt);
</pre><pre class="jdocu_small" style="color: black">uint8 *
dbuffer_prepend_external_data(dbuffer_t *dbuffer, void *data,
                              size_t len, int adopt);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions work similar to <b><i>dbuffer_append</i></b> and
   <b><i>dbuffer_prepend</i></b>, but with the difference that the data
   isn't copied.  Instead, the buffer will reference the data pointed
   to directly.
 <p>
   If the <i>adopt</i> flag is true, the control of the data
   block is transferred to the dbuffer.  It is assumed to be a block
   allocated with <b><i>MM_MALLOC</i></b>, and will be freed with
   <b><i>MM_FREE</i></b> when the dbuffer is released.
 <p>
   If the <i>adopt</i> flag is false, the dbuffer will not
   free the memory. Instead it is up to the caller to free the memory,
   but it must not do so before the dbuffer is freed.  Actually, this
   reference could be copied to other dbuffers, so great care has to
   be taken.  This should only be used for buffers that will only be
   read, since it hard to know if a write operation will actually
   write to the buffer or to a copy.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label1058">
       dbuffer_append</a>,  dbuffer_prepend
   </dl>
<a name="label1063"></a><h6 class="jdocu">dbuffer_append_value()</h6 class="jdocu">

<a name="label1064"></a><a name="label1065"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1066"></a><b>dbuffer_append_value</b><b>, dbuffer_prepend_value</b> &#8212; Add data with uniform content</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">uint8 *
dbuffer_append_value(dbuffer_t *dbuffer, int value, size_t len);
</pre><pre class="jdocu_small" style="color: black">uint8 *
dbuffer_prepend_value(dbuffer_t *dbuffer, int value, size_t len);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This adds data to a dbuffer and sets all the added bytes to
   <i>value</i>.  It has the same effect as using
   <b><i>dbuffer_append</i></b> or <b><i>dbuffer_append</i></b> and calling
   <b><i>memset</i></b> to set the contents.
<p>
   The return value is a pointer to the data just added.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label1058">
       dbuffer_append</a>,  dbuffer_prepend
   </dl>
<a name="label1067"></a><h6 class="jdocu">dbuffer_clone()</h6 class="jdocu">

<a name="label1068"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1069"></a><b>dbuffer_clone</b> &#8212; Make a full copy of another buffer</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">dbuffer_t *
dbuffer_clone(dbuffer_t *dbuffer);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function returns a new dbuffer that contains the same data as
   the buffer given in the <i>dbuffer</i> parameter.  This
   doesn't involve copying any memory, since they can share the same
   storage initially.  However, they are still completely independent,
   and operations on one buffer has no effect on the other.
<p>
   The returned dbuffer should be released with
   <b><i>dbuffer_free</i></b> when it is no longer needed.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label1105">
       new_dbuffer</a>, <a class="jdocu" href="#label1076"> dbuffer_free
   </a></dl>
<a name="label1070"></a><h6 class="jdocu">dbuffer_copy_append()</h6 class="jdocu">

<a name="label1071"></a><a name="label1072"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1073"></a><b>dbuffer_copy_append</b><b>, dbuffer_copy_prepend</b> &#8212; Copy data from a dbuffer</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
dbuffer_copy_append(dbuffer_t *dst, dbuffer_t *src,
                    size_t offset, size_t len);
</pre><pre class="jdocu_small" style="color: black">void
dbuffer_copy_prepend(dbuffer_t *dst, dbuffer_t *src,
                     size_t offset, size_t len);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions copies <i>len</i> bytes from the dbuffer
   <i>src</i>, at offset <i>offset</i>, and adds it to
   the beginning or end of the dbuffer <i>dst</i>.
<p>
   This can often be done without actually copying any memory, so it
   is usually very efficient.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label1058">
       dbuffer_append</a>,  dbuffer_prepend
   </dl>
<a name="label1074"></a><h6 class="jdocu">dbuffer_free()</h6 class="jdocu">

<a name="label1075"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1076"></a><b>dbuffer_free</b> &#8212; Release a dbuffer</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
dbuffer_free(dbuffer_t *dbuffer);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Release a dbuffer that will not be used anymore.  This will also
   free any data in the buffer that isn't also used by other buffers.
   After calling this function, the dbuffer must not be used anymore.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label1105">
       new_dbuffer
   </a></dl>
<a name="label1077"></a><h6 class="jdocu">dbuffer_len()</h6 class="jdocu">

<a name="label1078"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1079"></a><b>dbuffer_len</b> &#8212; Get the size of a dbuffer</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">size_t
dbuffer_len(dbuffer_t *dbuffer);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function returns the amount of data stored in a dbuffer.  This
   is the number of bytes that will be returned by
   <b><i>dbuffer_read_all</i></b>.</dd>

<p>
</dl>
<a name="label1080"></a><h6 class="jdocu">dbuffer_read()</h6 class="jdocu">

<a name="label1081"></a><a name="label1082"></a><a name="label1083"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1084"></a><b>dbuffer_read</b><b>, dbuffer_read_all</b><b>, dbuffer_read_some</b> &#8212; Extract data for reading</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">uint8 *
dbuffer_read(dbuffer_t *dbuffer, size_t offset, size_t len);
</pre><pre class="jdocu_small" style="color: black">uint8 *
dbuffer_read_all(dbuffer_t *dbuffer);
</pre><pre class="jdocu_small" style="color: black">uint8 *
dbuffer_read_some(dbuffer_t *dbuffer, size_t offset, size_t len,
                  size_t *actual_len);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <i>offset</i> and <i>len</i> parameters specify
   a region of the buffer to read from.  The returned pointer is
   guaranteed to point to a contiguous block of memory of size
   <i>len</i>.  It is illegal to write to the block return by
   these functions, since they may be shared by other dbuffers.  Use
   the <b><i>dbuffer_update</i></b> functions if you need to both read
   and write to the dbuffer.
 <p>
   The returned pointer is only valid until the next operation on the
   dbuffer, except for calling <b><i>dbuffer_len</i></b>.
<p>
   The <i>offset</i> and <i>len</i> must specify a
   valid region, so that the end of the region is not past the end of
   the dbuffer.
 <p>
   The <b><i>dbuffer_read_some</i></b> function takes an
   <i>actual_len</i> parameter, and may return a smaller
   buffer than requested.  The actual number of valid bytes in the
   returned buffer is stored in *<i>actual_len</i>.  It will
   return a smaller buffer if it would have had to copy memory to
   return a pointer to the whole region.  This means that you can use
   this function repeatedly to extract all the requested data in the
   most efficient way.  If <tt>NULL</tt> is passed for
   <i>actual_len</i>, it will return the full region.
 <p>
   The <b><i>dbuffer_read_all</i></b> function assumes 0 for
   <i>offset</i>, and <tt>buffer_len(dbuffer)</tt> for
   <i>len</i>.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label1102">
       dbuffer_update</a>, <a class="jdocu" href="#label1094"> dbuffer_replace
   </a></dl>
<a name="label1085"></a><h6 class="jdocu">dbuffer_remove()</h6 class="jdocu">

<a name="label1086"></a><a name="label1087"></a><a name="label1088"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1089"></a><b>dbuffer_remove</b><b>, dbuffer_remove_head</b><b>, dbuffer_remove_tail</b> &#8212; Remove data from a dbuffer</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">void
dbuffer_remove(dbuffer_t *dbuffer, size_t offset, size_t remove_len);
</pre><pre class="jdocu_small" style="color: black">void
dbuffer_remove_head(dbuffer_t *dbuffer, size_t remove_len);
</pre><pre class="jdocu_small" style="color: black">void
dbuffer_remove_tail(dbuffer_t *dbuffer, size_t remove_len);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
These functions will remove <i>remove_len</i> bytes from
   <i>dbuffer</i>.  The <b><i>dbuffer</i></b> will remove data
   starting at <i>offset</i>, while the other functions will
   remove data from the beginning or end of the buffer..
<p>
   This usually doesn't involve moving any memory contents, and should
   be very efficient even if the buffer is large.</dd>

<p>
</dl>
<a name="label1090"></a><h6 class="jdocu">dbuffer_replace()</h6 class="jdocu">

<a name="label1091"></a><a name="label1092"></a><a name="label1093"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1094"></a><b>dbuffer_replace</b><b>, dbuffer_replace_all</b><b>, dbuffer_replace_some</b> &#8212; Replace data</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">uint8 *
dbuffer_replace(dbuffer_t *dbuffer, size_t offset, size_t len);
</pre><pre class="jdocu_small" style="color: black">uint8 *
dbuffer_replace_all(dbuffer_t *dbuffer);
</pre><pre class="jdocu_small" style="color: black">uint8 *
dbuffer_replace_some(dbuffer_t *dbuffer, size_t offset, size_t len, size_t *actual_len);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <i>offset</i> and <i>len</i> parameters specify
   a region of the buffer to write to.  The returned pointer is
   guaranteed to point to a contiguous block of memory of size
   <i>len</i>, but is not guaranteed to contain the existing
   data in the buffer.  Use these functions when completely replacing
   a region of the buffer with new data.
 <p>
   The returned pointer is only valid until the next operation on the
   dbuffer, except for calling <b><i>dbuffer_len</i></b>.
<p>
   The <i>offset</i> and <i>len</i> must specify a
   valid region, so that the end of the region is not past the end of
   the dbuffer.
<p>
   The <b><i>dbuffer_replace_some</i></b> function takes an
   <i>actual_len</i> parameter, and may return a smaller
   buffer than requested.  The actual number of valid bytes in the
   returned buffer is stored in *<i>actual_len</i>.  It will
   return a smaller buffer if it would have had to copy memory to
   return a pointer to the whole region.  This means that you can use
   this function repeatedly to write all the requested data in the
   most efficient way.  If <tt>NULL</tt> is passed for
   <i>actual_len</i>, it will return the full region.
 <p>
   The <b><i>dbuffer_replace_all</i></b> function assumes 0 for
   <i>offset</i>, and <tt>buffer_len(dbuffer)</tt> for
   <i>len</i>.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label1084">
       dbuffer_read</a>, <a class="jdocu" href="#label1102"> dbuffer_update
   </a></dl>
<a name="label1095"></a><h6 class="jdocu">dbuffer_split()</h6 class="jdocu">

<a name="label1096"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1097"></a><b>dbuffer_split</b> &#8212; Split a dbuffer</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">dbuffer_t *
dbuffer_split(dbuffer_t *dbuffer, size_t offset);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function returns a new dbuffer that contains the
   <i>offset</i> first bytes from <i>dbuffer</i>, and
   removes those bytes from <i>dbuffer</i>  The effect is that
   the dbuffer is split in two halves, leaving the second half in the
   original dbuffer and returning the first half as a new dbuffer.
<p>

   The returned dbuffer should be released with
   <b><i>dbuffer_free</i></b> when it is no longer needed.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label1105">
       new_dbuffer</a>, <a class="jdocu" href="#label1076"> dbuffer_free
   </a></dl>
<a name="label1098"></a><h6 class="jdocu">dbuffer_update()</h6 class="jdocu">

<a name="label1099"></a><a name="label1100"></a><a name="label1101"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1102"></a><b>dbuffer_update</b><b>, dbuffer_update_all</b><b>, dbuffer_update_some</b> &#8212; Extract data for updating</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">uint8 *
dbuffer_update(dbuffer_t *dbuffer, size_t offset, size_t len);
</pre><pre class="jdocu_small" style="color: black">uint8 *
dbuffer_update_all(dbuffer_t *dbuffer);
</pre><pre class="jdocu_small" style="color: black">uint8 *
dbuffer_update_some(dbuffer_t *dbuffer, size_t offset, size_t len, size_t *actual_len);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
The <i>offset</i> and <i>len</i> parameters specify
   a region of the buffer to access.  The returned pointer is
   guaranteed to point to a contiguous block of memory of size
   <i>len</i>.  The block can be used for reading and writing
   data to the dbuffer.
 <p>
   The returned pointer is only valid until the next operation on the
   dbuffer, except for calling <b><i>dbuffer_len</i></b>.
<p>
   The <i>offset</i> and <i>len</i> must specify a
   valid region, so that the end of the region is not past the end of
   the dbuffer.
 <p>
   The <b><i>dbuffer_update_some</i></b> function takes an
   <i>actual_len</i> parameter, and may return a smaller
   buffer than requested.  The actual number of valid bytes in the
   returned buffer is stored in *<i>actual_len</i>.  It will
   return a smaller buffer if it would have had to copy memory to
   return a pointer to the whole region.  This means that you can use
   this function repeatedly to access all the requested data in the
   most efficient way.  If <tt>NULL</tt> is passed for
   <i>actual_len</i>, it will return the full region.
 <p>
   The <b><i>dbuffer_update_all</i></b> function assumes 0 for
   <i>offset</i>, and <tt>buffer_len(dbuffer)</tt> for
   <i>len</i>.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label1084">
       dbuffer_read</a>, <a class="jdocu" href="#label1094"> dbuffer_replace
   </a></dl>
<a name="label1103"></a><h6 class="jdocu">new_dbuffer()</h6 class="jdocu">

<a name="label1104"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1105"></a><b>new_dbuffer</b> &#8212; Create a new dbuffer</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">dbuffer_t *
new_dbuffer(void);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
This function returns an empty dbuffer. Use it when you need a new
   dbuffer, and call <b><i>dbuffer_free</i></b> when it isn't needed
   anymore.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label1076">
       dbuffer_free</a>, <a class="jdocu" href="#label1069"> dbuffer_clone
   </a></dl>


    <a name="label1106"></a><h4 class="jdocu">3.3.6&nbsp;&nbsp;&nbsp;VTMEM</h4 class="jdocu">

    
<p>
    <a name="label1107"></a><h5 class="jdocu">3.3.6.1&nbsp;&nbsp;&nbsp;VTmem Overview</h5 class="jdocu">

   
   The "VTmem" (Virtutech Memory Management) module provides a generic
   mechanism for creating and managing dynamic objects in C, as a
   replacement for the standard <b><i>malloc()</i></b>.
   This support is designed to support various
   forms of debugging, performance tuning, leak detection, etc. The
   facilities as a whole are called "VTmem"; most functions have
   the prefix <tt>mm_</tt>, and most macros have the prefix <tt>MM_</tt>.
   <a name="label1108"></a><h5 class="jdocu">3.3.6.2&nbsp;&nbsp;&nbsp;Creating and Deleting Objects</h5 class="jdocu">

   
   To create an VTmem object, you use macros such as <b><i>MM_MALLOC()</i></b>,
   which replace calls to <b><i>malloc()</i></b>.
   For example, to allocate 13 objects of type <tt>device_t</tt>, use
<p>
<pre class="jdocu_small" style="color: black">
    device_t *d = MM_MALLOC(13, device_t);
</pre>
<p>
   The specified type is used for keeping track of the total amount of
   memory used for each kind of object, and for knowing the size of
   the allocation (and being able to return a correctly casted
   pointer). This means that it must be possible to get a pointer to
   the type by appending an asterisk to the type name; so
   <tt>struct foo *</tt> is acceptable, but <tt>int (*)(void)</tt>
   is not. Use a typedef in these cases.
<p>
   There are also macros for specifying the size in bytes, and variants
   that return memory initialised with zero bytes. It is also possible
   to specify a desired address alignment.
<p>
   Since the allocation sites are tracked by file and line number, it is
   a good idea to avoid having more than one allocation call in a single
   source line.
<p>
   <a name="label1109"></a><h5 class="jdocu">3.3.6.3&nbsp;&nbsp;&nbsp;Exported Interface</h5 class="jdocu">

   
   This is the entire interface to the VTmem facility.
   <a name="label1110"></a><h6 class="jdocu">VTMEM Macros</h6 class="jdocu">
<a name="label1111"></a><h6 class="jdocu">MM_FREE()</h6 class="jdocu">

<a name="label1112"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1113"></a><b>MM_FREE</b> &#8212; free vtmem object</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">MM_FREE(p);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>MM_FREE</i></b> frees a vtmem object. It is legal to pass a null
  pointer, in which case it does nothing.</dd>

<p>
</dl>
<a name="label1114"></a><h6 class="jdocu">MM_MALIGN()</h6 class="jdocu">

<a name="label1115"></a><a name="label1116"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1117"></a><b>MM_MALIGN</b><b>, MM_ZALIGN</b> &#8212; allocate aligned memory</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">MM_MALIGN(align, nelems, type);
</pre><pre class="jdocu_small" style="color: black">MM_ZALIGN(align, nelems, type);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>MM_MALIGN</i></b> allocates memory aligned to the nearest
  <i>align</i>-byte boundary. The <i>align</i> parameter must
  be an even power of 2.
<p>
  <b><i>MM_ZALIGN</i></b> does the same thing but in addition zeroes out
  the allocated memory.
<p>
  Allocated aligned memory imposes a slightly higher space overhead
  than ordinary memory as handed out by <b><i>MM_MALLOC</i></b>. The
  overhead is of the order of <i>align</i> bytes per allocation.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Pointer to the allocated object.</dd>
</dl>
<a name="label1118"></a><h6 class="jdocu">MM_MALLOC()</h6 class="jdocu">

<a name="label1119"></a><a name="label1120"></a><a name="label1121"></a><a name="label1122"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1123"></a><b>MM_MALLOC</b><b>, MM_MALLOC_SZ</b><b>, MM_ZALLOC</b><b>, MM_ZALLOC_SZ</b> &#8212; allocate memory object</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">MM_MALLOC(nelems, type);
</pre><pre class="jdocu_small" style="color: black">MM_MALLOC_SZ(size, type);
</pre><pre class="jdocu_small" style="color: black">MM_ZALLOC(nelems, type);
</pre><pre class="jdocu_small" style="color: black">MM_ZALLOC_SZ(size, type);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>MM_MALLOC</i></b> allocates <i>nelems</i> objects of
  <i>type</i>.
<p>
  <b><i>MM_MALLOC_SZ</i></b> specifies the allocation in bytes, which can be
  occasionally useful.
<p>
  <b><i>MM_ZALLOC</i></b> and <b><i>MM_ZALLOC_SZ</i></b> do the same thing as their
  Z-less counterparts but in addition zero out the allocated memory.
<p>
  If <i>nelems</i> or <i>size</i> are zero, a null pointer is returned.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Pointer to the allocated object.</dd>
</dl>
<a name="label1124"></a><h6 class="jdocu">MM_REALLOC()</h6 class="jdocu">

<a name="label1125"></a><a name="label1126"></a><a name="label1127"></a><a name="label1128"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1129"></a><b>MM_REALLOC</b><b>, MM_REALLOC_SZ</b><b>, MM_ZREALLOC</b><b>, MM_ZREALLOC_SZ</b> &#8212; reallocate memory</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">MM_REALLOC(p, nelems, type);
</pre><pre class="jdocu_small" style="color: black">MM_REALLOC_SZ(p, size, type);
</pre><pre class="jdocu_small" style="color: black">MM_ZREALLOC(p, nelems, type);
</pre><pre class="jdocu_small" style="color: black">MM_ZREALLOC_SZ(p, size, type);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
<b><i>MM_REALLOC</i></b> changes the size of an allocated memory block to
  <i>nelems</i> elements.
<p>
  <b><i>MM_REALLOC_SZ</i></b> specifies the new size in bytes.
<p>
  <b><i>MM_ZREALLOC</i></b> and <b><i>MM_ZREALLOC_SZ</i></b> do the same
  thing as their Z-less counterparts, but in addition zero out the
  extended part of the allocation.
<p>
  If the passed pointer is <tt>NULL</tt>, then these macros are
  equivalent to an allocation of the desired amount. If
  <i>nelems</i> or <i>size</i> are zero, a null pointer is
  returned and the original allocation is freed.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Pointer to the reallocated
  object.</dd>
</dl>
<a name="label1130"></a><h6 class="jdocu">MM_STRDUP()</h6 class="jdocu">

<a name="label1131"></a>
<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1132"></a><b>MM_STRDUP</b> &#8212; duplicate a string</dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">MM_STRDUP(str);
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Corresponds to the traditional <b><i>strdup()</i></b> function, but
  uses the instrumentation of the Simics memory allocator.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
Pointer to the newly allocated
  string.</dd>
</dl>

   
<p>
    
    <a name="label1133"></a><h4 class="jdocu">3.3.7&nbsp;&nbsp;&nbsp;Python-specific Functions</h4 class="jdocu">


<p>
This list describes the Python-specific functions that are available for
writing commands, scripts and Python modules in Simics.
<p>
<a name="label1134"></a><h5 class="jdocu">Function List</h5 class="jdocu">
<a name="label1135"></a><h6 class="jdocu">cli.arg()</h6 class="jdocu">

<p>








<a name="label1136"></a>
<a name="label1137"></a>

<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1138"></a><b>arg</b> &#8212; define a command argument</dd>

<p>
<dt class="jdocu_descitem">NAMESPACE</dt><dd>
<tt>cli</tt></dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">
arg(handler, name = "", spec = "1", default = None, data = None,
        doc = "", expander = None, pars = [], is_a = None)
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Define a CLI command argument when using <b><i>new_command()</i></b>. A complete explanation of <b><i>new_command()</i></b> and <b><i>arg()</i></b> is available in the <em>Simics Programming Guide</em>.</dd>

<p>
</dl>
<a name="label1139"></a><h6 class="jdocu">cli.eval_cli_line()</h6 class="jdocu">

<p>










<a name="label1140"></a>
<a name="label1141"></a>

<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1142"></a><b>eval_cli_line</b> &#8212; evaluate a CLI command line</dd>

<p>
<dt class="jdocu_descitem">NAMESPACE</dt><dd>
<tt>cli</tt></dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">
eval_cli_line(text, user_typed = 0)
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Evaluate a CLI command line as if it has been entered at the prompt. This is useful to re-use existing command code when writing Python scripts. Command errors are printed on the console, and not reported back to Python. Note that the <tt>!</tt> and <tt>@</tt> modifiers are not supported when using <b><i>eval_cli_line()</i></b>.</dd>

<p>
</dl>
<a name="label1143"></a><h6 class="jdocu">cli.get_available_object_name()</h6 class="jdocu">

<p>








<a name="label1144"></a>
<a name="label1145"></a>

<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1146"></a><b>get_available_object_name</b> &#8212; return a non-allocated object name</dd>

<p>
<dt class="jdocu_descitem">NAMESPACE</dt><dd>
<tt>cli</tt></dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">
get_available_object_name(prefix)
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return an object name suitable for creating a new object (i.e., that has not been used yet) based on the <i>prefix</i> passed as argument.</dd>

<p>
</dl>
<a name="label1147"></a><h6 class="jdocu">cli.new_command()</h6 class="jdocu">

<p>







<a name="label1148"></a>
<a name="label1149"></a>

<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1150"></a><b>new_command</b> &#8212; define a new CLI command</dd>

<p>
<dt class="jdocu_descitem">NAMESPACE</dt><dd>
<tt>cli</tt></dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">
new_command(name, fun, args = [], doc = "", type = "misc commands",
                pri = 0, infix = 0, left = 1,
                short = "", group_short = "", alias = [], doc_with = "",
                check_args = 2,
                doc_items = [], see_also = [], namespace = "",
                method = "", namespace_copy = (), internal = 0,
                filename = "", linenumber = "", module = "",
                object = None, repeat = None, deprecated = None)
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Define a new CLI command. A complete explanation of <b><i>new_command()</i></b> is available in the <em>Simics Programming Guide</em>.</dd>

<p>
</dl>
<a name="label1151"></a><h6 class="jdocu">cli.number_str()</h6 class="jdocu">

<p>










<a name="label1152"></a>
<a name="label1153"></a>

<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1154"></a><b>number_str</b> &#8212; return a ready-to-print representation of a number</dd>

<p>
<dt class="jdocu_descitem">NAMESPACE</dt><dd>
<tt>cli</tt></dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">
number_str(val, radix = -1)
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Return a ready-to-print representation of the number <i>val</i> in a given base (<i>radix</i>) or the current base by default&#8212;following the current settings for number representation.</dd>

<p>
<dt class="jdocu_descitem">RETURN VALUE</dt><dd>
A string representing the number.</dd>
</dl>
<a name="label1155"></a><h6 class="jdocu">cli.object_expander()</h6 class="jdocu">

<p>



















<a name="label1156"></a>
<a name="label1157"></a>

<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1158"></a><b>object_expander</b> &#8212; Standard expander for an object argument</dd>

<p>
<dt class="jdocu_descitem">NAMESPACE</dt><dd>
<tt>cli</tt></dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">
object_expander(kind)
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
For command writing: standard expander that can be use to provide argument completion on all objects of a given class or matching a given interface (<i>kind</i>). For example, to expand a string with the list of processor available in the machine, you would write: <pre class="jdocu_small" style="color: black"> arg(str_t, "cpu", expander =  object_expander("processor")) </pre> To expand a string to all <b>gcache</b> objects: <pre class="jdocu_small" style="color: black"> arg(str_t, "cache", expander = object_expander("gcache")) </pre></dd>

<p>
</dl>
<a name="label1159"></a><h6 class="jdocu">cli.quiet_run_command()</h6 class="jdocu">

<p>














<a name="label1160"></a>
<a name="label1161"></a>

<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1162"></a><b>quiet_run_command</b> &#8212; Run a CLI command and return output</dd>

<p>
<dt class="jdocu_descitem">NAMESPACE</dt><dd>
<tt>cli</tt></dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">
quiet_run_command(text)
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Runs a CLI command, or a CLI expression, as if it has been entered at the prompt. Errors are reported using CliError exception. The <b><i>quiet_run_command()</i></b> is similar to <b><i>run_command()</i></b> but returns a tuple with the command return value as first entry, and the text output as the second. Note that the <tt>!</tt> and <tt>@</tt> modifiers are not supported when using <b><i>quiet_run_command()</i></b>.</dd>

<p>
</dl>
<a name="label1163"></a><h6 class="jdocu">cli.run_command()</h6 class="jdocu">

<p>











<a name="label1164"></a>
<a name="label1165"></a>

<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1166"></a><b>run_command</b> &#8212; Run a CLI command</dd>

<p>
<dt class="jdocu_descitem">NAMESPACE</dt><dd>
<tt>cli</tt></dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">
run_command(text)
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Runs a CLI command, or a CLI expression, as if it has been entered at the prompt. Errors are reported using CliError exception, and any return value from the command is returned by this function to Python. Note that the <tt>!</tt> and <tt>@</tt> modifiers are not supported when using <b><i>run_command()</i></b>.</dd>

<p>
</dl>
<a name="label1167"></a><h6 class="jdocu">sim_commands.new_info_command()</h6 class="jdocu">

<p>





















<a name="label1168"></a>
<a name="label1169"></a>

<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1170"></a><b>new_info_command</b> &#8212; define a new info command</dd>

<p>
<dt class="jdocu_descitem">NAMESPACE</dt><dd>
<tt>sim_commands</tt></dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">
new_info_command(cls, get_info, ctype = None)
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Define a new <b>info</b> command for a given device. <i>cls</i> is the class for which the <b>info</b> command should be registered. <i>get_info</i> is a function returning the information to be printed. <i>get_info()</i> should return a data structure of the following kind: <tt> [(SectionName1, [(DataName1.1, DataValue1.1),                  (DataName1.2, DataValue1.2), ...]),  (SectionName2, [(DataName2.1, DataValue2.1),                  (DataName2.2, DataValue2.2), ...]),  ...] </tt> Each section will be printed separately. Each piece of data will be printed on one line. If no sections are necessary, just provide <tt>None</tt> as the only section's name, followed by the list of data.</dd>

<p>
</dl>
<a name="label1171"></a><h6 class="jdocu">sim_commands.new_status_command()</h6 class="jdocu">

<p>











<a name="label1172"></a>
<a name="label1173"></a>

<p>
<dl class="jdocu_di">

<p>
<dt class="jdocu_descitem">NAME</dt><dd>
<a name="label1174"></a><b>new_status_command</b> &#8212; define a new status command</dd>

<p>
<dt class="jdocu_descitem">NAMESPACE</dt><dd>
<tt>sim_commands</tt></dd>

<p>
<dt class="jdocu_descitem">SYNOPSIS</dt><dd>
<pre class="jdocu_small" style="color: black">
new_status_command(cls, get_status, ctype = None)
</pre></dd>

<p>
<dt class="jdocu_descitem">DESCRIPTION</dt><dd>
Define a new <b>status</b> command for a given device. <i>cls</i> is the class for which the <b>status</b> command should be registered. <i>get_status</i> is a function returning the information to be printed. <i>get_status()</i> should return a data structure of the same kind as in <b><i>new_info_command()</i></b>.</dd>

<p>
<dt class="jdocu_descitem">SEE ALSO</dt><dd>
<a class="jdocu" href="#label1170">sim_commands.new_info_command</a></dl>


<p>
<p class="jdocu_navbarp"><span class="jdocu_navbar">VIRTUTECH CONFIDENTIAL&nbsp;&nbsp;&nbsp;&nbsp;<a class="jdocu" href="topic7.html">Previous</a> - <a class="jdocu" href="topic5.html">Up</a> - <a class="jdocu" href="topic9.html">Next</a></span></p>
</body>
</html>
